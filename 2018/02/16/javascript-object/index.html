<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 객체 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/02/16/javascript-object/"/>
<meta name="description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 객체">
<meta property="og:url" content="http://yoursite.com/2018/02/16/javascript-object/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-03-23T14:18:47.409Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 객체">
<meta name="twitter:description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-02-16 10:07:20"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 객체</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-02-16T01:07:20.000Z" itemprop="datePublished">2018-02-16 10:07:20</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Javascript/">Javascript</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Javascript/Basic/">Basic</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p>자바스크립트의 기본 데이터 타입은 <strong>객체</strong>다.<br>객체는 일종의 <strong>복합체</strong>로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,<br>값을 가져올 수 있다.<br>즉, <strong>객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합</strong>이다.</p>
<p>프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열을 값에 대응시키는 구조라고 할 수 있다.<br>이런 대응관계는 많은 자료구조들이 제공하는, 친근한 개념이다.<br>(해시, 해시 테이블, 사전, 연관배열 등)</p>
<p>하지만 객체는 단순히 문자열과 값의 대응관계인 것은 아니다.<br>자바스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 <strong>‘프로토타입’</strong>이라고 하는 다른 객체의 프로퍼티를 <strong>상속</strong>받는다.<br>객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 <strong>‘프로토타입 상속’</strong>이라고 한다.<br>(프로토타입 상속은 자바스크립트의 핵심적 특징이다)</p>
<p>자바스크립트 객체는 프로퍼티를 동적으로 추가하고 제거할 수 있기 때문에 동적이다.<br>하지만 자바스크립트의 객체는 정적 객체를 흉내 낼 수도 있고,<br>정적 타입 언어에서의 ‘구조체’처럼 사용할 수도 있다.<br>또한 문자열-값 매핑에서 값을 무시하면 문자열 집합을 표현하는 데도 사용할 수 있다.</p>
<p>자바스크립트에서는 문자열(string)과 숫자(number), true/false, null/undefined를 제외한 나머지는 객체다.<br>위 값들은 객체는 아니지만 변경 불가능 객체처럼 동작한다.</p>
<p>객체는 변경이 가능하며, 그 값 대신에 <strong>참조(reference)</strong>를 통해 조작한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line"></span><br><span class="line">y[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//변수 y를 통한 객체 수정</span></span><br><span class="line"></span><br><span class="line">x; <span class="comment">//&#123;a : 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>변수 x가 object를 가르키고 변수 y에 x를 할당한다면,<br>객체 자체를 복사하지 않고 객체를 <strong>참조</strong>한다.<br>그렇기 때문에, 변수 y를 통한 객체의 수정은 변수 x를 통해서도 확인이 가능하다.</p>
<p>객체로 가장 많이하는 작업은<br>객체를 생성한 후, 프로퍼티를 추가, 질의, 삭제, 테스트, 열거하는 것이다.<br>앞으로 이러한 기본적인 연산들에 대해 다룰 것이다.</p>
<p>프로퍼티는 이름과 값으로 구성된다.<br><strong>프로퍼티 이름</strong>은 빈 문자열을 포함한 어떤 문자열이든 될 수 있다.<br>하지만, 객체가 같은 이름의 프로퍼티를 두 개 가질 수는 없다.<br><strong>프로퍼티 값</strong>은 자바스크립트의 어떠한 값이든 될 수 있고,<br>ECMAScript5에서는 getter와 setter 함수도 될 수 있다.</p>
<p>프로퍼티의 이름과 값 이외에,<br>객체의 각 프로퍼티는 <strong>‘프로퍼티 속성(property attribute)’</strong>이라고 하는 연관된 값을 갖는다.</p>
<ul>
<li><strong>쓰기(writable)</strong> 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.</li>
<li><strong>열거(enumerable)</strong> 속성은 프로퍼티의 이름을 <code>for/in</code> 루프에서 읽을 수 있는지 여부를 결정한다.</li>
<li><strong>설정(configurable)</strong> 속성은 프로퍼티의 삭제 가능여부와 프로퍼티 속성의 변경 가능여부를 결정한다.</li>
</ul>
<p>ECMAScript5 이전에는 코드에서 생성한 객체의 프로퍼티는 전부 수정, 열거, 설정할 수 있었다.<br>하지만, 이후 부터는 사용자가 만든 프로퍼티의 속성만을 변경할 수 있다.</p>
<p>프로퍼티 뿐만 아니라,<br>모든 객체는 세 가지의 <strong>속성(object attribute)</strong>을 갖는다.</p>
<ul>
<li><strong>prototype</strong>은 상속받은 프로퍼티들을 가진 객체를 참조한다.</li>
<li><strong>class</strong>는 객체의 자료형(타입)을 특정짓는 문자열이다.</li>
<li><strong>extensible</strong>속성은 객체에 새 프로퍼티를 추가할 수 있는지를 결정한다.(ECMAScript5)</li>
</ul>
<p><br><br>세 종류의 자바스크립트 객체</p>
<ul>
<li><strong>네이티브 객체(native object)</strong>는 ECMAScript 명세에 정의된 객체 또는 그 객체의 클래스다.<br><code>Array</code>, <code>Function</code>, <code>Date</code>, <code>정규표현식</code>들은 전부 네이티브 객체이다.</li>
<li><strong>호스트 객체(host object)</strong>는 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다.<br><code>HTMLElement</code> 객체는 웹 페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체다.<br>호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 <code>Function</code> 객체로 정의하는 것과 마찬가지로,<br>호스트 객체는 네이티브 객체일 수도 있다.</li>
<li><strong>사용자 정의 객체(user-defined object)</strong>는 자바스크립트 코드의 실행으로 생성된 객체다.</li>
</ul>
<p>두 종류의 프로퍼티</p>
<ul>
<li><strong>고유 프로퍼티(own property)</strong>는 객체에 직접 정의된 프로퍼티다.</li>
<li><strong>상속받은 프로퍼티(inherited property)</strong>는 객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.</li>
</ul>
<p><br><br><br></p>
<h1 id="객체-생성하기"><a href="#객체-생성하기" class="headerlink" title="객체 생성하기"></a>객체 생성하기</h1><p><strong>객체 리터럴</strong>을 통해 만들 수도 있고, <code>new</code>키워드를 사용해 만들 수도 있으며,<br>ECMAScript5의 <strong>Object.create()</strong> 함수를 통해 생성할 수도 있다.<br><br></p>
<h2 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="- 객체 리터럴"></a>- 객체 리터럴</h2><p>객체를 생성하는 가장 쉬운 방법이다.<br>객체 리터럴은 중괄호(<code>{}</code>)안에, 이름과 값을 콜론(<code>:</code>)으로 구분한 순서 쌍을 쉼표(<code>,</code>)로 연결한 리스트다.<br>프로퍼티 이름으로는 자바스크립트 식별자 또는 문자열을 사용할 수 있다.<br>프로퍼티 값으로는 자바스크립트 표현식을 사용할 수 있다.<br>(표현식의 값(원시 값 또는 객체 값)은 곧 프로퍼티의 값이 된다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;                           <span class="comment">//빈 객체</span></span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span> &#125;;                 <span class="comment">//두 개의 프로퍼티</span></span><br><span class="line"><span class="keyword">var</span> point2 = &#123; <span class="attr">x</span>:point.x, <span class="attr">y</span>:point.y &#125;;    <span class="comment">//프로퍼티를 수식의 값으로 정의</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"JavaScript"</span>,           <span class="comment">//프로퍼티 이름은 공백과</span></span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">"The Definitive Guide"</span>,  <span class="comment">//하이픈을 포함할 수 있다</span></span><br><span class="line">    <span class="string">"for"</span>: <span class="string">"all audiences"</span>,               <span class="comment">//예약어는 인용부호로 둘러싸서 문자열 리터럴로 사용</span></span><br><span class="line">    author: &#123;                             <span class="comment">//프로퍼티 author의 값은 객체이다</span></span><br><span class="line">        firstname: <span class="string">"David"</span>,               <span class="comment">//프로퍼티 이름은 인용부호로 감싸지 않을 수도 있다</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ECMAScript5와 ECMAScript3 일부 구현에서는 <strong>예약어</strong>를 <strong>인용부호(<code>&quot; &#39;</code>)</strong>로 감싸지 않고도 프로퍼티를 이름으로 사용할 수 있다.<br>하지만 일반적으로 ECMAScript3 에서 프로퍼티 이름으로 예약어를 사용하려면 반드시 인용부호로 감싸야 한다.</p>
<p>ECMAScript5에서 객체 리터럴의 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span>,        <span class="comment">//이 쉼표는 무시된다</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>대부분 ECMAScript3 구현체가 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시하지만 IE는 이를 Error로 간주한다.</p>
<p><strong>객체 리터럴은 평가될 때마다 새로운 객체를 생성하고 초기화하는 표현식</strong>이다.<br>각 프로퍼티의 값 또한 리터럴이 평가될 때마다 새롭게 계산된다.<br>즉, 하나의 객체 리터럴은 수많은 객체를 만들 수 있다.<br>객체 리터럴이 반복적으로 호출되는 함수 내부의 루프 몸체에 있는경우,<br>매 순간 생기는 객체의 프로퍼티 값들은 서로 다를것이다.<br><br></p>
<h2 id="new"><a href="#new" class="headerlink" title="- new"></a>- new</h2><p><code>new</code>연산자는 객체를 만들고 초기화한다.<br><code>new</code>키워드 다음에는 반드시 함수 호출문이 와야한다.<br>이때 호출되는 함수를 <strong>생성자(constructor)</strong>라고 하는데, <strong>새로 생성된 객체를 초기화</strong>하는 역할을 한다.<br>코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>);</span><br></pre></td></tr></table></figure></p>
<p>기본 타입에 대한 생성자 뿐만 아니라,<br>원하는 형태의 객체를 생성하고 초기화하기 위해 임의의 생성자 함수를 직접 정의할 수도 있다.<br><br></p>
<h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="- 프로토타입"></a>- 프로토타입</h2><p><strong>Object.create()</strong>를 보기전에 먼저 프로토타입에 대해 알아야만 한다.<br>자바스크립트의 모든 객체(A)는 또 다른 자바스크립트 객체(극히 드물지만 null일 수도 있음)와 연관되어 있다.<br>이 연관된 객체를 <strong>프로토타입(prototype)</strong>이라고 한다.<br>객체(A)는 프로토타입으로부터 프로퍼티들을 <strong>상속</strong>받는다.</p>
<p>객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며,<br>이 프로토타입 객체는 <strong>Object.prototype</strong>으로 참조할 수 있다.</p>
<p><code>new</code>키워드를 사용해 생성자를 호출하면, 생성자 함수의 프로토타입이 생성된 객체의 프로토타입이 된다.<br>따라서 <strong>new Object()</strong>로 생성된 객체는 <strong>{}</strong>로 생성된 객체와 마찬가지로  <strong>Object.prototype</strong>를 상속받는다.<br>마찬가지로, <strong>new Array()</strong>로 생성된 객체는 <strong>Array.prototype*을 객체의 프로토타입으로 사용하고,
</strong>new Date()<strong>로 생성된 객체는 </strong>Date.prototype**을 객체의 프로토타입으로 사용한다.</p>
<p><strong>Object.prototype</strong>은 프로토타입이 없는 매우 드문 객체 중 하나다.<br>즉, 아무런 프로퍼티도 상속받지 않는다.<br><strong>Object</strong>는 <strong>최상위</strong>이기 때문이다.</p>
<p><strong>Object</strong>가 <strong>최상위</strong> 이기 때문에,<br>다른 프로토타입 객체들은 보통 프로토타입을 갖는다.<br>모든 내장 생성자는 <strong>Object.prototype</strong>을 상속하는 객체를 프로토타입으로 갖는다.</p>
<p><strong>Date.prototype</strong>은 <strong>Object.prototype</strong>의 프로퍼티들을 상속받는다.<br>따라서 <strong>Date()</strong>로 생성된 Date객체는 <strong>Object.prototype</strong>를 상속받은 <strong>Date.prototype</strong>의 프로퍼티들을 상속받게 된다.</p>
<blockquote>
<p>Object.prototype - Date.prototype - new Date()</p>
</blockquote>
<p>이처럼 프로토타입 객체들이 연결된 것을 <strong>‘프로토타입 체인’</strong>이라고 한다.<br><br></p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="- Object.create()"></a>- Object.create()</h2><p>ECMAScript5는 객체를 생성하는 <strong>Object.create()</strong> 메서드를 지원한다.<br>이 메서드의 첫 번째 인자가 프로토타입 객체다.<br><strong>Object.create()</strong>는 새 객체의 프로퍼티 정보를 두 번째 인자로 받을 수 있는데, 두 번째 인자는 생략이 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(프로토타입 객체, [프로퍼티 설정]);</span><br></pre></td></tr></table></figure></p>
<p><strong>Object.create()</strong>는 정적 함수로 개별 객체를 통해 호출되는 메서드가 아니다.<br>함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;); <span class="comment">//o는 x,y 프로퍼티를 상속받는다</span></span><br></pre></td></tr></table></figure></p>
<p>이 <strong>Object.create()</strong>를 사용하는 것은 <strong>{}</strong>나 <strong>new Object()</strong>로 생성하는 것과 완전히 다르다.<br>해당 객체를 상속받아 생성하기 때문에 두 방법과는 달리 한번 더 프로토타입이 감싸져 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">X</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// &#123;&#125;</span></span><br><span class="line">   <span class="comment">//  __proto__:</span></span><br><span class="line">   <span class="comment">//     x: 1</span></span><br><span class="line">   <span class="comment">//     __proto__: Object</span></span><br><span class="line"></span><br><span class="line">b; <span class="comment">// &#123;x:1&#125;</span></span><br><span class="line">   <span class="comment">//  __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>a의 경우 다음과 같은 구조이다.</p>
<blockquote>
<p>Object.prototype - {x:1} - a</p>
</blockquote>
<p>b의 경우 다음과 같은 구조이다.</p>
<blockquote>
<p>Object.prototype - b</p>
</blockquote>
<p>프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>그러나 이렇게 생성된 객체는 어떠한 객체도 상속받지 않기 때문에 toString() 같은 기본적인 메서드조차 사용할 수 없다.<br>즉, <code>+</code> 연산자도 사용할 수 없다.<br>만약 <strong>{}</strong> 또는 <strong>new Object()</strong>가 만들어내는 것과 같은 일반적인 빈 객체를 반들고 싶으면 <strong>Object.prototype</strong>을 전달하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var o = &#123;&#125;; var o = new Object(); 와 완전히 동일</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure></p>
<p>임의의 프로토타입으로 새 객체를 만들 수 있다는 점(특정 객체를 상속받는 <strong>‘상속자’</strong>객체를 만들 수 있다는 점)에서 매우 유용하다,<br>ECMAScript3에서는 다음과 같이 구현할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 객체 o의 속성을 상속받아 새로운 객체를 생성하여 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">//o는 null이 아닌 객체여야 한다</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Object.create()를 사용 가능한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) &#123;              <span class="comment">//Object.create()를 사용할 수 있다면</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(o);      <span class="comment">//Object.create()를 사용하고 객체를 생성하여 반환</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Object.create()를 사용하지 못하는 경우</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> o;                 <span class="comment">//만약 객체의 타입검사가 필요한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;                  <span class="comment">//임시로 빈 생성자 함수를 정의</span></span><br><span class="line">    f.prototype = o;                  <span class="comment">//f의 프로토타입 프로퍼티를 o로 설정</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();                   <span class="comment">//함수 f()를 사용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 <strong>inherit()</strong> 함수는 <strong>Object.create()</strong>를 대체할 만큼 완벽하지 않다.<br><strong>inherit()</strong> 함수는 객체 생성 시 빈 프로토타입 객체를 통해 만들 수 없고,<br><strong>Object.create()</strong>의 두 번째 인자(생성할 객체의 프로퍼티 설정)과 같은 선택 인자를 받지 않는다.</p>
<p><strong>inherit()</strong> 함수를 사용하면, 객체가 임의의 라이브러리 함수에 의해 뜻하지 않게 수정되는 것을 막을 수 있다.<br>함수에 객체를 직접 전달하는 대신 해당 객체의 프로퍼티를 상속한 객체를 전달하는 것이다.<br>따라서 함수가 프로퍼티를 읽는다면, 상속받은 값을 보게된다.<br>만약 함수가 프로퍼티를 설정한다면, 이는 기존의 객체가 아닌 새로 만들어진 객체에만 영향을 미친다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = inherit(a);</span><br><span class="line">b[<span class="string">"y"</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">//&#123;x:1&#125;</span></span><br><span class="line">b; <span class="comment">//&#123;x:1, y:2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="프로퍼티-접근-및-설정"><a href="#프로퍼티-접근-및-설정" class="headerlink" title="프로퍼티 접근 및 설정"></a>프로퍼티 접근 및 설정</h1><p>프로퍼티의 값을 가져오기 위해서는 마침표(<code>.</code>) 연산자 또는 대괄호(<code>[]</code>) 연산자를 사용한다.<br>연산자 좌측에는 객체로 평가되는 표현식이 와야 한다.<br>마침표(<code>.</code>) 연산자를 사용할 경우에는 연산자 우측에 반드시 프로퍼티 이름이 식별자로 와야한다.<br>대괄호(<code>[]</code>) 연산자를 사용할 경우, 대괄호(<code>[]</code>)안의 값은 반드시 프로퍼티 이름의 문자열로 평가되는 표현식이어야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = book.author;       <span class="comment">//book객체에서 author 프로퍼티를 가져옴</span></span><br><span class="line"><span class="keyword">var</span> name = author.surname;      <span class="comment">//author객체에서 surname 프로퍼티를 가져옴</span></span><br><span class="line"><span class="keyword">var</span> title = book[<span class="string">"main title"</span>]; <span class="comment">//book객체에서 main title 프로퍼티를 가져옴</span></span><br></pre></td></tr></table></figure></p>
<p>프로퍼티를 만들거나 설정하기 위해서는 객체의 프로퍼티에 접근할 때와 동일하게 마침표(<code>.</code>) 또는 대괄호(<code>[]</code>) 연산자를 사용한다.<br>이때 프로퍼티는 할당 표현식의 왼쪽에 위치한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.edition = <span class="number">6</span>;                   <span class="comment">//edition 프로퍼티를 만든다</span></span><br><span class="line">book[<span class="string">"main title"</span>] = <span class="string">"ECMAScript"</span>;  <span class="comment">//main title 프로퍼티를 만든다</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript3 에서는 마침표(<code>.</code>) 연산자 다음에 오는 식별자로 예약어를 사용할 수 없다.<br>즉, <strong>o.for</strong> 나 <strong>o.class</strong> 처럼 할 수 없다.<br><code>for</code>는 언어에서 사용하는 키워드고, <code>class</code>는 추후에 사용하라고 예약된 단어다.<br>만약 객체에 프로퍼티 이름으로 예약어를 사용하려면 <strong>o[‘for’]</strong>나 <strong>o[‘class’]</strong>처럼 반드시 <code>[]</code>연산자를 사용해야 한다.<br>일부 ECMAScript3 구현체와 ECMAScript5는 이러한 제한을 완화해 마침표(<code>.</code>) 연산자 다음에 예약어를 사용할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//일부 ECMAScript3 구현체와 ECMAScript5</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.for = <span class="number">1</span>;  <span class="comment">//OK!</span></span><br><span class="line"></span><br><span class="line">o;          <span class="comment">//&#123;for:1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>[]</code>연산자를 사용할 경우, 연산자 안에 문자열로 평가되는 표현식이 들어가야 한다.<br>정확히 말해, 문자열 표현식 또는 값이 <strong>문자열로 변환될 수 있는 표현식</strong>이어야 한다는 말이다.<br>그래서 숫자가 가능한 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="number">1</span>] = <span class="number">22</span>;  <span class="comment">//OK!</span></span><br><span class="line"></span><br><span class="line">o;          <span class="comment">//&#123;1:22&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>위에서 <strong>1</strong>은 문자열 <strong>“1”</strong>로 평가되어 들어간다.<br><br></p>
<h2 id="연관-배열로서의-객체"><a href="#연관-배열로서의-객체" class="headerlink" title="- 연관 배열로서의 객체"></a>- 연관 배열로서의 객체</h2><p>자바스크립트에서 프로퍼티에 접근하는 것은 앞에서와 같이 <code>.</code>와 <code>[]</code>가 사용 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.property</span><br><span class="line">object[<span class="string">"property"</span>]</span><br></pre></td></tr></table></figure></p>
<p>마침표(<code>.</code>) 연산자와 식별자를 사용하는 것은, 마치 C의 구조체나 자바 객체의 필드에 접근할 때 사용하는 구문과 유사하다.<br>대괄호(<code>[]</code>)와 문자열을 사용하는 것은, 마치 숫자가 아닌 문자열을 인덱스로 갖는 배열에 접근하는 형태와 유사하다.<br>이러한 형태의 배열을 <strong>연관 배열(associative array)</strong>라 하고, 해시(hash)나 맵(map), 사전(dictionary)이라고도 한다.<br>모든 자바스크립트의 객체는 연관 배열이다.</p>
<p>C나 C++, 자바와 같이 타입의 제약이 엄격한 언어에서 객체는 오직 정해진 개수의 프로퍼티를 갖고,<br>반드시 프로퍼티의 이름을 미리 정의해야 한다.</p>
<p>반면 자바스크립트는 타입의 제약이 느슨하기 때문에, 이와같은 규칙이 적용되지 않는다.<br>그래서 객체 안에 수많은 프로퍼티들을 만들 수 있다.</p>
<p>하지만 마침표(<code>.</code>) 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 반드시 식별자로 표현해야 한다.<br>식별자는 자바스크립트 프로그램에 직접 타이핑해 넣은 이름이며 자료형이 없으므로 프로그램이 실행되는 도중에 변경할 수 없다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.property     <span class="comment">//OK!</span></span><br><span class="line">object.prop + erty  <span class="comment">//NO!</span></span><br></pre></td></tr></table></figure></p>
<p>반면에 <code>[]</code> 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 문자열로 표현한다.<br>문자열은 자바스크립트의 자료형이므로 프로그램 실행중에 생성하고 조작할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object[<span class="string">"property"</span>]    <span class="comment">//OK!</span></span><br><span class="line">object[<span class="string">"prop"</span>+<span class="string">"erty"</span>] <span class="comment">//OK!</span></span><br></pre></td></tr></table></figure></p>
<p>그래서 아래와 같은 조작도 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    addr += customer[<span class="string">"address"</span>+i] + <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이 코드는 <strong>customer</strong>객체의 address1에서 address4까지 프로퍼티를 읽고 변수 addr에 차례대로 이어 붙인다.<br>이 예는 객체의 프로퍼티에 접근하기 위해 문자열 표현식(<code>&quot;&quot;</code>)과 배열의 표기법(<code>[]</code>)을 함께 사용하는 방식의 유연함을 보여준다.</p>
<p>마침표(<code>.</code>)연산자는 제약이 있다.<br>다음과 같이 사용자가 프로그램 실행 중에 프로퍼티를 입력하는 경우에는 사전에 프로퍼티 이름을 알 수 없다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addstock</span>(<span class="params">portfolio, stockname, shares</span>) </span>&#123;</span><br><span class="line">    portfolio[stockname] = shares;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>프로퍼티 이름을 미리 알 방법이 없기 때문에, 객체의 프로퍼티에 접근하기 위해 마침표(<code>.</code>) 연산자를 사용할 수 없다.<br>하지만, <code>[]</code>연산자는 접근이 가능하다.<br><br></p>
<h2 id="상속"><a href="#상속" class="headerlink" title="- 상속"></a>- 상속</h2><p>자바스크립트 객체는 고유 프로퍼티들을 가지고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티를 상속받는다.</p>
<p>예를 들어, 객체 o에서 프로퍼티 x를 찾는다.<br>객체 o가 프로퍼티 x를 가지고 있지 않으면, o의 프로토타입 객체에서 x를 찾는다.<br>만약 프로토타입 객체에 고유 프로퍼티 x가 없다면,<br>해당 프로토타입 객체는 해당 객체 내 프로토타입 객체에서 프로퍼티 x를 찾는다.<br>이 작업은 프로퍼티 x를 찾거나 <code>prototype</code>이 <strong>null</strong>인 객체가 발견될 떄까지 계속된다.</p>
<p>이처럼 객체의 <code>prototype</code> 속성은 프로퍼티가 계승되는 체인 또는 연결 리스트를 생성한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 객체 o의 속성을 상속받아 새로운 객체를 생성하여 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">//o는 null이 아닌 객체여야 한다</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Object.create()를 사용 가능한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) &#123;              <span class="comment">//Object.create()를 사용할 수 있다면</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(o);      <span class="comment">//Object.create()를 사용하고 객체를 생성하여 반환</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Object.create()를 사용하지 못하는 경우</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> o;                 <span class="comment">//만약 객체의 타입검사가 필요한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;                  <span class="comment">//임시로 빈 생성자 함수를 정의</span></span><br><span class="line">    f.prototype = o;                  <span class="comment">//f의 프로토타입 프로퍼티를 o로 설정</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();                   <span class="comment">//함수 f()를 사용</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;             <span class="comment">//o는 Object.prototype을 상속받은 객체</span></span><br><span class="line">o.x = <span class="number">1</span>;                <span class="comment">//o는 고유 프로퍼티 x를 갖는다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = inherit(o);     <span class="comment">//p는 객체 o를 상속받은 객체</span></span><br><span class="line">p.y = <span class="number">2</span>;                <span class="comment">//p는 고유 프로퍼티 y를 갖는다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q = inherit(p);     <span class="comment">//q는 객체 p를 상속받은 객체</span></span><br><span class="line">q.z = <span class="number">3</span>;                <span class="comment">//q는 고유 프로퍼티 z를 갖는다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = q.toString();   <span class="comment">//q는 상위에 Object.prototype을 상속받았기 때문에 toString()을 사용할 수 있다</span></span><br><span class="line"></span><br><span class="line">q.x + q.y;              <span class="comment">//3</span></span><br><span class="line">                        <span class="comment">//x는 객체 o, y는 객체 p에서 상속 받았다</span></span><br></pre></td></tr></table></figure></p>
<p>여기서 만약 객체 o의 프로퍼티 x에 값을 설정하는 경우를 생각하자.<br>객체 o의 프로퍼티 x는 고유 프로퍼티이다.<br>그러므로 단순히 프로퍼티 x의 값을 수정할 수 있다.</p>
<p>만약 객체 o에 고유 프로퍼티 x가 존재하지 않고,<br>x가 상속받은 상태이거나 없는 경우, 객체 o에 <strong>새로운 고유 프로퍼티</strong> x를 생성하여 값을 설정한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;      <span class="comment">//a는 고유 프로퍼티 x를 갖는다</span></span><br><span class="line"><span class="keyword">var</span> o = inherit(a); <span class="comment">//o는 객체 a를 상속 받는다</span></span><br><span class="line"></span><br><span class="line">o.x;                <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">o.x = <span class="number">2</span>;            <span class="comment">//객체 o에 새로운 고유프로퍼티 x를 생성하여 2를 할당</span></span><br><span class="line">o.x;                <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">o;                  <span class="comment">//&#123;</span></span><br><span class="line">                    <span class="comment">//  x:2</span></span><br><span class="line">                    <span class="comment">//      __proto__:</span></span><br><span class="line">                    <span class="comment">//          x:1</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>객체의 프로퍼티에 값을 설정할 때는<br>해당 프로퍼티에 값을 설정할 수 있는지 알아보기 위해 <strong>프로토타입 체인</strong>을 검사하게 된다.</p>
<p>예를 들어, 객체 o가 상속한 프로퍼티 x가 <strong>읽기 전용</strong>이라면 해당 프로퍼티에는 값을 설정할 수 없다.<br>하지만 값 설정이 허용된다면 원래 객체에 <strong>새로운 프로퍼티</strong>가 만들어지거나 그 값이 설정되며,<br>프로토타입 체인은 변경되지 않는다.</p>
<p>프로퍼티를 질의할 때는 상속이 동작하지만 설정할 때는 그렇지 않다는 것은 자바스크립트의 중요한 특징 중 하나다.<br>계승된 프로퍼티를 선택적으로 재정의할 수 있기 때문이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unitcircle = &#123;<span class="attr">r</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> c = inherit(unitcircle);    <span class="comment">//객체 c는 unitcircle을 상속받으므로 프로퍼티 r도 상속 받음</span></span><br><span class="line"></span><br><span class="line">c.x = <span class="number">1</span>; c.y = <span class="number">2</span>;               <span class="comment">//고유 프로퍼티 x와 y를 정의</span></span><br><span class="line">c.r = <span class="number">3</span>;                        <span class="comment">//상속받은 프로퍼티 r을 재정의</span></span><br><span class="line"></span><br><span class="line">unitcircle.r;                   <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>객체 프로퍼티에 대한 대입연산은 실패할 수도 있고,<br>해당 객체에 새 프로퍼티를 만들게 될 수도 있고,<br>그 값을 바꾸게 될 수도 있다.</p>
<p>하지만 한 가지 주의 해야할 예외가 있다.<br>예를 들어, 객체 o가 프로퍼티 x를 상위 객체로 부터 상속받았고,<br>이 프로퍼티 x가 <strong>setter</strong> 메서드를 가진 접근자 프로퍼티라고 가정하자.<br>이런 경우 객체 o의 x에 접근할 경우 새 프로퍼티 x가 만들어지는 대신,<br>상속받은 프로퍼티 x가 가진 <strong>setter</strong> 메서드가 호출된다.<br>하지만, 이 setter 메서드는 프로퍼티 x가 정의된 프로토타입 객체에 호출되는 것이 아니라,<br>객체 o에서 호출된다.</p>
<p>따라서 이 메서드가 새로운 프로퍼티를 정의하게 된다면 그 프로퍼티는 객체 o에 추가되며,<br>프로토타입 체인은 변경되지 않는다.<br><br></p>
<h2 id="프로퍼티-접근-에러"><a href="#프로퍼티-접근-에러" class="headerlink" title="- 프로퍼티 접근 에러"></a>- 프로퍼티 접근 에러</h2><p>프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나, 값을 설정할 수 있는 것은 아니다.<br><strong>존재하지 않는 프로퍼티</strong>에 접근해도 에러가 발생하지 않는다.</p>
<p>만약 프로퍼티 x가 객체 o의 고유 프로퍼티나 상속된 프로퍼티로서 존재하지 않을 경우에,<br>프로퍼티 접근 표현식 o.x는 <strong>undefined</strong>로 평가된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">a.y;            <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>하지만 <strong>존재하지 않는 객체</strong>의 프로퍼티에 접근하려고 하면 에러가 발생한다.<br>그 객체는 null이나 undefined로 어떠한 프로퍼티도 갖지 않기 때문에 에러가 발생한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">a.y;            <span class="comment">//undefined</span></span><br><span class="line">a.y.length;     <span class="comment">//Uncaught TypeError: Cannot read property 'length' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b;          <span class="comment">//undefined</span></span><br><span class="line">b.x;            <span class="comment">//Uncaught TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure></p>
<p>이러한 경우가 있기 때문에 예외 처리 방법이 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#1. 구체적이고 확실한 방법</span></span><br><span class="line"><span class="keyword">var</span> len = undefiend;</span><br><span class="line"><span class="keyword">if</span> (book) &#123;</span><br><span class="line">    <span class="keyword">if</span> (book.subtitle) &#123;            <span class="comment">//subtitle 프로퍼티가 존재하는 경우에만 작동</span></span><br><span class="line">        len = book.subtitle.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#2. 간단하고 관용적인 방법</span></span><br><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure></p>
<p>null이나 undefined에 프로퍼티를 설정하려고 해도 TypeError 예외가 발생한다.</p>
<p>하지만 null이나 undefined가 아닌 값이라 해도, 항상 프로퍼티를 설정할 수 있는것은 아니다.<br>프로퍼티가 <strong>읽기 전용 속성</strong>을 갖고 있다면 값을 설정할 수 없고, 새 프로퍼티를 추가하는 것을 허용하지 않을 수 있다.</p>
<p>하지만 아래 예제는 <strong>읽기 전용 속성</strong>이지만 예외가 발생하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 내장된 생성자의 프로토타입 프로퍼티들은 읽기 전용이다</span></span><br><span class="line"><span class="built_in">Object</span>.prototype = <span class="number">0</span>;   <span class="comment">//예외 없이 실행은 되나 바뀌지 않는다</span></span><br></pre></td></tr></table></figure></p>
<p>이 것은 자바스크립트 오래된 버그이다.<br>ECMAScript5의 <strong>엄격 모드(strict mode)</strong>에서 수정되었다.<br>엄격 모드에서는 프로퍼티에 값을 설정하는 데 실패하면 TypeError가 발생한다.</p>
<p>프로퍼티 설정이 성공, 실패할지 판단하는 규칙은 직관적이지만 간결히 표현하기는 어렵다.<br>다음과 같은 경우에는 객체 o의 프로퍼티 p를 설정할 수 없다.</p>
<ul>
<li><strong>객체 o가 고유 프로퍼티 p를 가지고 있고, 읽기 전용인 경우</strong>:<br>읽기 전용 프로퍼티 p에 값을 설정할 수 없다.<br>(<strong>configurable read-only</strong> 프로퍼티라면 예외적으로 값을 설정할 수 있다. definedProperty() 메서드 참고)</li>
<li><strong>객체 o는 상속된 프로퍼티 p를 가지고 있고, 프로퍼티 p가 읽기 전용인 경우:</strong><br>상속된 읽기 전용 프로퍼티 p는 동일한 이름의 고유 프로퍼티로 감출수 없다.</li>
<li><strong>객체 o에 고유 프로퍼티 p가 없고, 상속된 프로퍼티 p도 없고, 객체 o의 extensible 속성이 false인 경우:</strong><br>만약 프로퍼티 p가 객체 o에 존재하지 않고, setter 메서드로 호출되지 않았다면 p는 반드시 객체 o에 추가되어야 한다.<br>하지만 객체 o에 <strong>extensible</strong> 속성이 <strong>ture</strong>가 아니라면 새로운 프로퍼티를 추가할 수 없다.</li>
</ul>
<p><br><br><br></p>
<h1 id="프로퍼티-삭제하기"><a href="#프로퍼티-삭제하기" class="headerlink" title="프로퍼티 삭제하기"></a>프로퍼티 삭제하기</h1><p><code>delete</code> 연산자는 객체의 프로퍼티를 삭제한다.<br><code>delete</code> 연산자는 하나의 피연산자를 갖는데, 이때 피연산자는 올바른 프로퍼티 접근 표현식이어야 한다.<br>이 연산자는 프로퍼티의 값을 지우는 것이 아니라 <strong>프로퍼티를 지운다</strong>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.author;     <span class="comment">//book 객체의 author 프로퍼티가 삭제됨</span></span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">"title"</span>];   <span class="comment">//book 객체의 title 프로퍼티가 삭제됨</span></span><br></pre></td></tr></table></figure></p>
<p><code>delete</code> 연산자는 상속받은 프로퍼티가 아닌 <strong>고유 프로퍼티만 지울 수 있다.</strong><br>(상속받은 프로퍼티를 지우기 위해서는 해당 프로퍼티가 정의된 프로토타입 객체에서 지워야한다.<br>삭제에 성공하면 해당 프로토타입 객체를 상속한 모든 객체가 영향을 받는다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = inherit(a); <span class="comment">//객체 b는 a를 상속받음</span></span><br><span class="line"></span><br><span class="line">b.x;                <span class="comment">//1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a.x;         <span class="comment">//객체 a의 프로퍼티 x를 삭제</span></span><br><span class="line"></span><br><span class="line">b.x;                <span class="comment">//undefiend</span></span><br></pre></td></tr></table></figure></p>
<p><code>delete</code> 표현식은 <strong>삭제에 성공</strong>하거나, 프로퍼티가 존재하지 않아서 <strong>아무 영향을 끼치지 못한 경우</strong>에 항상 <strong>true</strong>로 평가된다.<br><code>delete</code> 연산자의 피연산자가 올바른 프로퍼티 접근 표현식이 아닌 경우에도 <strong>true</strong>로 평가된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o.x;          <span class="comment">//true; 객체 o의 프로퍼티 x가 삭제되어 true를 반환</span></span><br><span class="line"><span class="keyword">delete</span> o.x;          <span class="comment">//true; 객체 o의 프로퍼티 x는 이미 삭제되었지만 true를 반환</span></span><br><span class="line"><span class="keyword">delete</span> o.toString(); <span class="comment">//true; toString()은 객체 o의 고유 프로퍼티가 아님</span></span><br><span class="line">                     <span class="comment">//      toString()이 삭제되지 않고 true를 반환</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>;            <span class="comment">//true; 올바른 프로퍼티 접근 표현식이 아니지만 true를 반환</span></span><br></pre></td></tr></table></figure></p>
<p><code>delete</code> 연산자는 <strong>configurable</strong> 속성이 <strong>false</strong> 인 프로퍼티를 지우지 않는다.<br>(하지만 <strong>‘확장할 수 없는(nonextensible)’</strong> 객체에 속한 <strong>configurable</strong> 속성이 <strong>true</strong>인 프로퍼티들은 지운다.)<br>내장 객체의 특정 프로퍼티들은, 변수 선언이나 함수 선언 결과로 만들어진 전역 객체 프로퍼티와 마찬가지로 속성을 변경할 수 없다(nonconfigurable).<br>엄격 모드에서 속성을 변경할 수 없는 프로퍼티를 지우려고 하면 TypeError가 발생한다.<br>ECMAScript3를 포함한 비엄격 모드에서는 단순히 false로 평가될 뿐이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">//Object.prototype은 속성 변경이 불가능한 프로퍼티이므로 지울 수 없다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;               <span class="comment">//전역 변수 x를 선언</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;           <span class="comment">//전역 객체의 프로퍼티 x는 지울 수 없다</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;          <span class="comment">//전역 함수 f를 선언</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f;           <span class="comment">//전역 객체의 함수 f는 지울 수 없다</span></span><br></pre></td></tr></table></figure></p>
<p>비엄격 모드에서 전역 객체의 설정 가능한 프로퍼티를 지울 때는,<br>전역 객체 참조는 생략하고 이름만으로 프로퍼티를 지울 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비엄격 모드</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;         <span class="comment">//var를 쓰지않고 전역 변수 x를 선언</span></span><br><span class="line"><span class="keyword">delete</span> x;           <span class="comment">//삭제됨</span></span><br></pre></td></tr></table></figure></p>
<p>하지만 엄격 모드에서는 <code>delete</code>에 x와 같이 <code>this</code>로 한정하지 않은 식별자를 피연산자로 사용하면 SyntaxError 예외가 발생한다.<br>따라서 프로퍼티 접근시에는 <strong>this.x</strong>와 같이 명시적으로 사용해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 엄격 모드</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;       <span class="comment">//var를 쓰지않고 전역 변수 x를 선언</span></span><br><span class="line"><span class="keyword">delete</span> x;          <span class="comment">//SyntaxError 발생</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;     <span class="comment">//삭제됨</span></span><br></pre></td></tr></table></figure></p>
<p><code>delete</code> 연산자로 삭제할 수 없는 경우는 다음과 같다.</p>
<ul>
<li><strong>configurable</strong> 속성이 <strong>false</strong> 인 경우</li>
<li>내장 객체의 특정 프로퍼티</li>
<li>상속받은 프로퍼티</li>
<li>변수 선언이나 함수 선언 결과로 만들어진 전역 객체 프로퍼티</li>
</ul>
<p><br><br><br></p>
<h1 id="프로퍼티-검사하기"><a href="#프로퍼티-검사하기" class="headerlink" title="프로퍼티 검사하기"></a>프로퍼티 검사하기</h1><p>자바스크립트 객체는 일종의 프로퍼티 집합이다.<br>떄떄로 이 집합에 주어진 이름의 프로퍼티가 있는지 검사할 필요가 있다.</p>
<p><code>in</code>연산자나 <strong>hasOwnProperty()</strong>혹은 <strong>propertyIsEnumerable()</strong> 메서드를 사용할 수 있고,<br>단순히 프로퍼티에 접근하는 것으로도 프로퍼티를 검사할 수 있다.</p>
<p><code>in</code> 연산자 왼쪽에는 프로퍼티 이름이 문자열로 와야 하고, 오른쪽은 객체가 와야한다.<br>객체에 해당 프로퍼티가 존재하면 <strong>true</strong>를 반환한다.<br>(상속받은 프로퍼티도 <strong>true</strong>를 반환한다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a = inherit(o);</span><br><span class="line"></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;    <span class="comment">//true; 객체 o에 고유 프로퍼티 x가 존재하므로 true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;    <span class="comment">//false; 객체 o에 프로퍼티 y가 존재하지 않으므로 false</span></span><br><span class="line"></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> a;    <span class="comment">//true; 객체 a에 상속받은 프로퍼티 x가 존재하므로 true</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>객체의 <strong>hasOwnProperty()</strong> 메서드는 주어진 이름의 프로퍼티가 객체에 존재하는 지 검사한다.<br>객체에 해당 프로퍼티가 존재하면 <strong>true</strong>를 반환한다.<br>(상속받은 프로퍼티는 <strong>false</strong>를 반환한다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a = inherit(o);</span><br><span class="line"></span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);  <span class="comment">//true; 객체 o에 고유 프로퍼티 x가 존재하므로 true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"y"</span>);  <span class="comment">//false; 객체 o에 프로퍼티 y가 존재하지 않으므로 false</span></span><br><span class="line"></span><br><span class="line">a.hasOwnProperty(<span class="string">"x"</span>);  <span class="comment">//false; 객체 o에 프로퍼티 x가 존재하나</span></span><br><span class="line">                        <span class="comment">//       상속받은 프로퍼티 이므로 false</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>객체의 <strong>propertyIsEnumerable()</strong> 메서드는 <strong>hasOwnProperty()</strong> 보다 상세한 검사를 한다.<br>객체에 주어진 이름의 <strong>고유 프로퍼티</strong>가 존재하고,<br><strong>열거할 수 있는(enumerable 속성이 true) 프로퍼티</strong>인 경우에만 <strong>true</strong>를 반환한다.<br>(상속받은 프로퍼티는 <strong>false</strong>를 반환한다)<br>일부 내장 프로퍼티들은 열거할 수 없다.<br>ECMAScript5 메서드 중에는 프로퍼티를 열거할 수 없게 만드는 메서드가 있다.<br>이를 사용하지 않는다면, 일반적으로 자바스크립트 코드로 생성한 프로퍼티들은 열거할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a = inherit(o);</span><br><span class="line"></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"x"</span>);  <span class="comment">//true; 객체 o에 고유 프로퍼티 x가 존재하고 열거할 수 있으므로 true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"y"</span>);  <span class="comment">//false; 객체 o에 프로퍼티 y가 존재하지 않으므로 false</span></span><br><span class="line"></span><br><span class="line">a.propertyIsEnumerable(<span class="string">"x"</span>);  <span class="comment">//false; 객체 o에 프로퍼티 x가 존재하나</span></span><br><span class="line">                              <span class="comment">//       상속받은 프로퍼티 이므로 false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty(<span class="string">"toString"</span>);       <span class="comment">//true; 내장 프로퍼티 이므로 true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">"toString"</span>); <span class="comment">//false; 내장 프로퍼티 이지만 열거할 수 없기 때문에 false</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>undefined가 아니지만 확인할 때는 <code>in</code> 연산자 대신 논리 연산자 <code>!==</code>를 사용하는 것이 효과적이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">//true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">//false</span></span><br><span class="line">o.toString() !== <span class="literal">undefined</span>; <span class="comment">//true; toString은 상속받은 프로퍼티</span></span><br></pre></td></tr></table></figure></p>
<p>방금 소개한 방법과 같이 단순히 프로퍼티를 접근하는 방법으로는 처리할 수 없는 경우가 있다.<br>이는 <code>in</code> 연산자로 처리할 수 있다.<br><code>in</code> 연산자를 사용하면 객체에 프로퍼티가 존재하지 않는 경우와,<br>객체에 프로퍼티가 존재하지만 값이 undefined 인 경우를 구별할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="literal">undefined</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">//false</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">//true; 객체 o에 프로퍼티 x가 존재함</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;                   <span class="comment">//false; 객체 o에 프로퍼티 y가 없음</span></span><br><span class="line"><span class="keyword">delete</span> o.x;                 <span class="comment">//프로퍼티 x를 제거</span></span><br><span class="line"></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">//false; 객체 o에 프로퍼티 x가 없음</span></span><br></pre></td></tr></table></figure></p>
<p><code>!==</code> 연산자는 null과 undefined를 구분할 수 있다.<br>하지만 이러한 구분 자체가 필요하지 않을 수도 있다.<br>이런 경우 <code>!=</code> 연산자를 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 o가 가진 프로퍼티 x의 값이 null이나 undefined가 아니라면, 2를 곱한다</span></span><br><span class="line"><span class="keyword">if</span> (o.x != <span class="literal">null</span>) &#123;</span><br><span class="line">    o.x *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 o가 가진 프로퍼티 x의 값이 false가 아니라면, 2를 곱한다</span></span><br><span class="line"><span class="comment">// (x가 undefined, null, false, '', 0, NaN 중 하나가 아니라면)</span></span><br><span class="line"><span class="keyword">if</span> (o.x) &#123;</span><br><span class="line">    o.x *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="프로퍼티-열거하기"><a href="#프로퍼티-열거하기" class="headerlink" title="프로퍼티 열거하기"></a>프로퍼티 열거하기</h1><p>객체가 가진 모든 프로퍼티를 순회하고 싶을 때 ECMAScript5는 두 가지 방법을 더 제공한다.<br>보통 <code>for/in</code> 루프로 해결한다.</p>
<p>지정한 객체가 가진 고유 프로퍼티 또는 상ㅎ속된 프로퍼티들 중 열거 가능한 프로퍼티들 마다 <code>for/in</code> 루프의 몸체가 실행된다.<br>상속받은 내장 메서드는 열거할 수 없지만, 사용자가 임의로 추가한 프로퍼티들은 열거할 수 있다.<br>(열거할 수 없도록 설정하는 함수를 사용하면 열거할 수 없다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = inherit(a); <span class="comment">//객체 b는 객체 a를 상속받음</span></span><br><span class="line">b.y = <span class="number">2</span>; b.z = <span class="number">3</span>;   <span class="comment">//객체 b에 고유 프로퍼티 y와 z를 추가</span></span><br><span class="line"></span><br><span class="line">b.propertyIsEnumerable(<span class="string">"toString"</span>); <span class="comment">//false; 열거할 수 없기 때문에 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> b) &#123;      <span class="comment">//객체 b의 모든 프로퍼티에 대해</span></span><br><span class="line">    <span class="built_in">console</span>.log(p); <span class="comment">//프로퍼티 이름을 출력</span></span><br><span class="line">                    <span class="comment">//x, y, z가 출력됨</span></span><br><span class="line">                    <span class="comment">//하지만 toString은 출력되지 않음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>일부 유용한 라이브러리들은 Object.prototype에 메서드나 프로퍼티들을 추가해서 모든 객체에서 사용할 수 있도록 하고 있다.<br>하지만 ECMAScript5 의 이전 버전에는 이 메서드나 프로퍼티들을 열거할 수 없도록(nonenumerable) 만들 방법이 없었으므로,<br><code>fon/in</code> 루프를 돌리면 항상 열거될 수 밖에 없었다.<br><code>for/in</code> 루프로 열거 되는것을 막고 싶다면, 다음 두 방법을 이용해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!o.hasOwnProperty(p)) <span class="keyword">continue</span>;       <span class="comment">//상속받은 프로퍼티는 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o[p] === <span class="string">"function"</span>) <span class="keyword">continue</span>; <span class="comment">//해당 프로퍼티가 메서드라면 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>다음과 같이 유용한 함수를 사용하여 객체의 프로퍼티들을 다룰 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 p의 열거 가능한 프로퍼티들을 객체 o에 복사 후 반환</span></span><br><span class="line"><span class="comment"> * 만약 객체 o와 p가 같은 이름의 프로퍼티를 갖고 있다면, 객체 o의 프로퍼티를 재정의한다</span></span><br><span class="line"><span class="comment"> * 이 함수는 getter/setter 메서드와 프로퍼티 속성까지는 복사하지 않는다</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(prop <span class="keyword">in</span> p) &#123;         <span class="comment">//p의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        o[prop] = p[prop];   <span class="comment">//o의 프로퍼티로 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 p의 열거 가능한 프로퍼티들을 객체 o에 복사 후 반환</span></span><br><span class="line"><span class="comment"> * 만약 객체 o와 p가 같은 이름의 프로퍼티를 갖고 있다면, 객체 o의 프로퍼티를 사용</span></span><br><span class="line"><span class="comment"> * 이 함수는 getter/setter 메서드와 프로퍼티 속성까지는 복사하지 않는다</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(prop <span class="keyword">in</span> p) &#123;                            <span class="comment">//p의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty[prop]) <span class="keyword">continue</span>;   <span class="comment">//객체 o에 같은 이름의 프로퍼티 존재시 건너뜀</span></span><br><span class="line">            o[prop] = p[prop];                  <span class="comment">//o의 프로퍼티로 추가</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o의 프로퍼티 중에 객체 p에 프로퍼티들을 객체 o에서 제거하고 o를 반환</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> o) &#123;                       <span class="comment">//p의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop <span class="keyword">in</span> p)) <span class="keyword">delete</span> o[prop];   <span class="comment">//p에 없는 프로퍼티를 삭제</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o의 프로퍼티 중에 객체 p와 중복되는 프로퍼티를 객체 o에서 제거하고 o를 반환</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;   <span class="comment">//p의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        <span class="keyword">delete</span> o[prop]; <span class="comment">//p와 중복되는 프로퍼티 제거</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o와 p가 가진 프로퍼티들을 새 객체에 담아 반환</span></span><br><span class="line"><span class="comment"> * 만약 같은 이름의 프로퍼티가 있다면 객체 p의 프로퍼티 값을 사용</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> extend(extend(&#123;&#125;, o), p);    <span class="comment">//1. 새로 생성한 객체에 o의 프로퍼티를 추가</span></span><br><span class="line">                                        <span class="comment">//2. 새로 생성한 객체에 p의 프로퍼티를 추가</span></span><br><span class="line">                                        <span class="comment">//   동일한 프로퍼티 이름이 있는경우 새로 생성한 객체의 프로퍼티를 재정의</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o의 프로퍼티 중에 객체 p와 중복되는 프로퍼티를 새 객체에 담아 반환</span></span><br><span class="line"><span class="comment"> * 프로퍼티의 값은 o를 사용</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restrict(extend(&#123;&#125;, o), p);  <span class="comment">//1. 새로 생성한 객체에 o의 프로퍼티를 추가</span></span><br><span class="line">                                        <span class="comment">//2. 새로 생성한 객체에 p에 없는 프로퍼티는 삭제</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o가 가진 열거 가능한 고유 프로퍼티의 이름만 배열에 담아 반환</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o !== <span class="string">"object"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();   <span class="comment">//반드시 객체 인자가 필요</span></span><br><span class="line">    <span class="keyword">var</span> result - [];                                <span class="comment">//반환할 배열 생성</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;                           <span class="comment">//객체 o의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        result.push(prop);                          <span class="comment">//프로퍼티 이름을 반환할 배열에 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>for/in</code>루프 말고도 ECMAScript5에서는 프로퍼티 이름을 열거하는 두 가지 함수를 제공한다.</p>
<p>첫 번째는 <strong>Object.keys()</strong> 함수로,<br>객체가 가진 <strong>열거할 수 있는 고유 프로퍼티</strong>의 이름을 <strong>배열</strong>에 담아 반환한다.<br>위 keys()함수와 같이 동작한다.</p>
<p>두 번째는 <strong>Object.getOwnPropertyNames()</strong> 함수로,<br>객체가 가진 <strong>모든 고유 프로퍼티</strong>의 이름을 <strong>배열</strong>에 담아 반환한다.<br><br><br><br></p>
<h1 id="프로퍼티-Getter와-Setter"><a href="#프로퍼티-Getter와-Setter" class="headerlink" title="프로퍼티 Getter와 Setter"></a>프로퍼티 Getter와 Setter</h1><p>ECMAScript5 에서 프로퍼티 값은 <strong>getter/setter</strong> 메서드로 대체할 수 있다.<br><strong>getter/setter</strong> 메서드로 정의된 프로퍼티는 단순히 값을 갖는 ‘데이터 프로퍼티’와 다른<br><strong>‘접근자 프로퍼티(accessor property)’</strong>라고 한다.</p>
<p>프로그램이 객체의 접근자 프로퍼티에 접근하면,<br>자바스크립트 엔진은 <strong>getter</strong> 메서드를 아무런 인자 없이 호출한다.<br>이떄, getter 메서드의 반환 값이 프로퍼티 접근 표현식의 값이 된다.</p>
<p>프로그램이 객체의 프로퍼티 값을 변경하려고 하면,<br>자바스크립트 엔진은 <strong>setter</strong> 메서드를 호출한다.<br>이때, 할당자(<code>=</code>)의 오른쪽에 있는 값은 setter 메서드의 인자로 전달한다.<br>setter 메서드는 프로퍼티의 값을 ‘설정’하는 것을 담당하고, 그 반환 값은 무시된다.</p>
<p>데이터 프로퍼티가 <strong>writable(쓰기)</strong> 속성을 갖는 반면,<br>접근자 프로퍼티는 쓰기 속성을 갖지 않는다.</p>
<p>만약 프로퍼티가 <strong>getter/setter</strong> 메서드를 모두 가지고 있으면 <strong>읽기/쓰기</strong>가 가능한 프로퍼티 인 것이고,<br>프로퍼티가 <strong>getter</strong>만 가지고 있다면 <strong>읽기 전용</strong> 프로퍼티 이다.<br>프로퍼티가 <strong>setter</strong>만 가지고 있다면 <strong>쓰기 전용</strong> 프로퍼티 이고,<br>이때 읽기를 시도하면 항상 undefined가 반환된다.<br>(데이터 프로퍼티는 쓰기 전용 프로퍼티를 만들 수 없다)</p>
<p>접근자 프로퍼티를 쉽게 정의하는 방법은 다음과 같이 확장된 객체 리터럴 문법을 사용하는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    data_prop: value,           <span class="comment">//데이터 프로퍼티</span></span><br><span class="line">    get accessor_prop() &#123;  &#125;,   <span class="comment">//접근자 프로퍼티</span></span><br><span class="line">    set accessor_prop(value) &#123;&#125; <span class="comment">//접근자 프로퍼티</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>접근자 프로퍼티는 그 이름이 프로퍼티 이름과 같은 하나 또는 두개의 <strong>함수</strong>다.<br>이때 함수 정의에 사용되는 <code>function</code> 키워드 대신 <code>get/set</code>을 사용하고,<br>기존 객체 프로퍼티 정의와는 달리 프로퍼티 이름 뒤에 콜론(<code>:</code>)을 사용하지 않는다.</p>
<p>하지만, 다른 프로퍼티와 구분하기 위해 함수 몸체 다음에 쉼표(<code>,</code>)가 필요하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    <span class="comment">//읽기 쓰기 속성을 가진 일반적인 데이터 프로퍼티</span></span><br><span class="line">    x: <span class="number">1.0</span>,</span><br><span class="line">    y: <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">//읽기 쓰기가 가능한 접근자 프로퍼티</span></span><br><span class="line">    get test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;,</span><br><span class="line">    set test(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//읽기 전용 접근자 프로퍼티</span></span><br><span class="line">    get onlyRead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.test;         <span class="comment">//1.0</span></span><br><span class="line">p.test = <span class="number">3</span>;     <span class="comment">//3</span></span><br><span class="line">p.test;         <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">p.onlyRead;     <span class="comment">//1.0</span></span><br><span class="line">p.onlyRead = <span class="number">3</span>; <span class="comment">//Error!</span></span><br></pre></td></tr></table></figure></p>
<p><strong>getter</strong>와 <strong>setter</strong> 함수 몸체에서 <code>this</code> 키워드를 사용하였다.<br>자바스크립트는 getter/setter 함수를 객체의 메서드로 호출하는데, 이는 함수의 몸체 안에 사용된 <code>this</code> 키워드가 객체 자신을 가리킨다는 뜻이다.<br>따라서 프로퍼티 test의 getter 메서드는 객체의 프로퍼티 x와 y를 <strong>this.x</strong>와 <strong>this.y</strong>로 접근할 수 있다.</p>
<p>접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    <span class="comment">//읽기 쓰기 속성을 가진 일반적인 데이터 프로퍼티</span></span><br><span class="line">    x: <span class="number">1.0</span>,</span><br><span class="line">    y: <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">//읽기 쓰기가 가능한 접근자 프로퍼티</span></span><br><span class="line">    get test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;,</span><br><span class="line">    set test(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//읽기 전용 접근자 프로퍼티</span></span><br><span class="line">    get onlyRead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = inherit(p); <span class="comment">//a는 객체 p를 상속받음</span></span><br><span class="line"></span><br><span class="line">a.test;             <span class="comment">//1.0</span></span><br><span class="line">a.test = <span class="number">2</span>;         <span class="comment">//2</span></span><br><span class="line">a.test;             <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="프로퍼티-속성"><a href="#프로퍼티-속성" class="headerlink" title="프로퍼티 속성"></a>프로퍼티 속성</h1><p>이름과 값 말고도, 프로퍼티에는 프로퍼티로 할 수 있는 작업을 결정하는 세가지 속성 <strong>writable</strong> 과 <strong>enumerable</strong>, <strong>configurable</strong>이 있다.</p>
<p><strong>writable</strong> 속성은 프로퍼티 값의 <strong>변경 가능 여부</strong>를 결정한다.<br><strong>enumerable</strong> 속성은 프로퍼티가 <strong>열거될 수 있는지 여부</strong>를 결정하고,<br><strong>configurable</strong> 속성은 configurable 속성뿐 아니라 writable 속성과 enumerable 속성 값의 변경 가능 여부를 결정한다.</p>
<p>ECMAScript3 프로그램으로 만드는 모든 프로퍼티는 변경가능, 열거가능, 설정가능 하며, 이를 변경할 방법은 없다.</p>
<p>ECMAScript5 API는 라이브러리를 만들 경우 중요하다.</p>
<ul>
<li>프로토타입 객체에 메서드를 추가할 수 있고, 추가된 메서드를 내장 메서드처럼 연결할 수 없게 만들 수 있다.</li>
<li>변경하거나 삭제할 수 없는 프로퍼티를 정의하여, 객체를 고정(lock down) 시킬 수 있다.</li>
</ul>
<p><strong>데이터 프로퍼티</strong>의 값 또한 속성이라고 할 수 있다.<br>데이터 프로퍼티의 네 가지 속성은 value, writable, enumerable, configurable 이다.</p>
<p><strong>접근자 프로퍼티</strong>는 value 속성이나 writable 속성을 갖지 않는데,<br>writable 속성은 setter 메서드의 존재 여부에 따라 결정되기 때문이다.<br>따라서 접근자 프로퍼티의 네 가지 속성은 get, set, enumerable, configurable 이다.</p>
<p>프로퍼티의 속성 값을 질의하고, 값을 설정하는 ECMAScript5 의 메서드는 접근자 프로퍼티의 네 가지 속성을 표현하기 위해 <strong>‘프로퍼티 디스크립터(property descriptor)’</strong> 라는 객체를 사용한다.<br>이 객체의 프로퍼티 이름은 표현 대상 속성의 이름과 같다.<br>따라서, 데이터 프로퍼티의 프로퍼티 디스크립터 객체는 value, writable, enumerable, configurable 등의 프로퍼티를 갖는다.<br>접근자 프로퍼티의 프로퍼티 디스크립터 객체는 get, set, enumerable, configurable 등의 프로퍼티를 갖는다.</p>
<p>writable, enumerable, configurable 프로퍼티는 boolean 값을 갖고,<br>get 과 set 프로퍼티는 function 을 값으로 갖는다.</p>
<p>객체가 가진 특정 프로퍼티에 대한 프로퍼티 디스크립터 객체는 <strong>Object.getOwnPropertyDescriptor()</strong>를 통해 얻을 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;를 반환</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// random 객체의 octet 프로퍼티 속성을 반환</span></span><br><span class="line"><span class="comment">// &#123;get: /*func*/, set: undefined, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(random, <span class="string">"octet"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상속받은 프로퍼티나 존재하지 않는 프로퍼티의 경우 undefined를 반환</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"x"</span>);        <span class="comment">// 존재하지 않는 프로퍼티</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"toString"</span>); <span class="comment">// 상속받은 프로퍼티</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Object.getOwnPropertyDescriptor()</strong>는 객체의 고유 프로퍼티에서만 동작한다.<br>상속된 프로퍼티의 속성을 검사하기 위해서는 프로토타입 체인을 명시적으로 직접 순회해야 한다.</p>
<p>프로퍼티 속성을 <strong>설정</strong>하거나 임의의 속성으로 <strong>새 프로퍼티</strong>를 만들기 위해<br><strong>Object.defineProperty()</strong>를 호출한다.<br>함수의 인자로, <strong>수정할 객체</strong>와 추가하거나 변경할 <strong>프로퍼티 이름</strong>, 프로퍼티의 <strong>디스크립터 객체</strong>를 넘긴다.</p>
<blockquote>
<p>Object.defineProperty( 수정할 객체, 프로퍼티 이름, 디스크립터 객체)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">//프로퍼티가 없는 빈 객체를 정의</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//열거할 수 없는 데이터 프로퍼티 x를 정의하고, 프로퍼티의 값을 1로 설정한다</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>,</span><br><span class="line">                                writable : <span class="literal">true</span>,</span><br><span class="line">                                enumerable : <span class="literal">false</span>,</span><br><span class="line">                                configurable : <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//위에서 정의한 프로퍼티 x를 열거할 수 있는지 검사</span></span><br><span class="line">o.x;            <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">//[] enumerable 이 false 이므로 열거되지 않는다</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 값 변경</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; <span class="attr">writable</span> : <span class="literal">false</span> &#125;);</span><br><span class="line">o.x = <span class="number">2</span>;        <span class="comment">//writable 이 false 이므로 값을 변경하지 못하거나, 엄격모드에서 TypeError가 발생</span></span><br><span class="line">o.x;            <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 x를 데이터 프로퍼티에서 접근자 프로퍼티로 변경</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o. <span class="string">"x"</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;&#125;);</span><br><span class="line">o.x;            <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.defineProperty()</strong> 에 인자로 넘긴 프로퍼티 디스크립터 객체에 반드시 네 개의 프로퍼티가 있어야 할 필요는 없다.<br>새 프로퍼티를 만들 때, 프로퍼티 디스크립터 객체에 생략된 속성은 false나 undefined로 처리된다.<br>기존 프로퍼티의 속성을 수정할 경우, 생략한 속성은 기존 값을 그대로 <strong>유지</strong>한다.<br><strong>Object.defineProperty()</strong> 메서드는 기존 프로퍼티나 새로만든 고유 프로퍼티 속성은 바꾸지만, 상속받은 속성은 바꾸지 않는다.</p>
<p>동시에 여러 개의 프로퍼티를 만들거나 수정하고 싶을 때는 <strong>Object.defineProperties()</strong>를 사용한다.<br>첫 번째 인자는 <strong>수정하려는 객체</strong>이고, 두 번째 인자는 <strong>객체에 만들거나 수정하려는 프로퍼티 이름</strong>과, 디스크립터 객체를 값으로 갖는 <strong>객체</strong>다.</p>
<blockquote>
<p>Object.defineProperties( 수정할 객체, 프로퍼티 이름과 디스크립터 객체)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 객체에 두 개의 데이터 프로퍼티와 읽기전용 접근자 프로퍼티 추가</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, &#123;</span><br><span class="line">    x: &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    y: &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    r: &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>ECMAScript5 메서드인 <strong>Object.create()</strong> 는 첫 번째 인자로 <strong>새로 생성할 객체의 프로토타입 객체</strong>를 넘긴다.<br>두 번째 선택인자로 객체에 만들거나 수정하려는 프로퍼티 이름과, 디스크립터 객체를 값으로 갖는 객체를 넘긴다.</p>
<blockquote>
<p>Object.create( 새로 생성할 객체의 프로토타입 객체, 프로퍼티 이름과 디스크립터 객체)</p>
</blockquote>
<p>Object.defineProperty()와 Object.defineProperties() 메서드를 프로퍼티를 추가하거나 수정할 수 없는 객체에 사용하면 TypeError가 발생한다.<br>확장 불가능한(nonextensible) 객체가 그런 경우다.<br>그 밖에도, 객체의 프로퍼티 속성 때문에 TypeError가 발생하기도 한다.</p>
<blockquote>
<p><strong>writable</strong> 속성 : value 속성의 변경 가능 여부를 결정<br><strong>configurable</strong> 속성 : configurable 속성 및 프로퍼티가 가진 다른 속성의 변경 여부를 결정<br>                       (프로퍼티가 삭제될 수 있는지도 결정)</p>
</blockquote>
<p>하지만 이런 규칙들이 직관적이지는 않다.<br>예를 들어, 프로퍼티의 writable 속성이 false라고 해도, configurable 속성이 true라면<br>프로퍼티의 값은 바꿀 수 있다.<br>또한, 프로퍼티의 writable 속성이 true이고, configurable 속성이 false라도, writable 속성을 false로 바꿀 수 있다.</p>
<p>그래서 <strong>Object.defineProperty()와 Object.defineProperties()은 다음 규칙을 위반시 TypeError</strong>가 발생한다.</p>
<ul>
<li>extensible 하지 않은 객체는, 기존의 고유 프로퍼티를 수정할 수는 있지만, 새 프로퍼티를 추가할 수는 없다.</li>
<li>프로퍼티의 configurable 속성 값이 false 면,<br>configurable 속성 값 뿐만아니라 enumerable 속성 값도 바꿀 수 없다.</li>
<li>접근자 프로퍼티의 configurable 속성 값이 false 면,<br>getter/setter 메서드를 변경할 수도 없고, 데이터 프로퍼티를 바꿀 수도 없다.</li>
<li>데이터 프로퍼티의 configurable 속성 값이 false 면,<br>데이터 프로퍼티를 접근자 프로퍼티로 바꿀 수 없다.</li>
<li>데이터 프로퍼티의 configurable 속성 값이 false 면,<br>기존의 writable 속성을 false 에서 true로 바꿀 수 없다.<br>(하지만, true에서 false로 변경은 가능하다)</li>
<li>데이터 프로퍼티의 configurable 속성 값과 writable 속성 값이 false 면,<br>프로퍼티 값을 바꿀 수 없다.</li>
<li>하지만 프로퍼티의 configurable 속성 값이 true고, writable 속성 값이 false 인 경우,<br>프로퍼티의 값은 바꿀 수 있다.<br>(writable 속성 값을 true로 만들고, 프로퍼티의 값을 수정하고, 수정 후 다시 writable 속성 값ㅇ르 false로 바꾸면 됨)</li>
</ul>
<p>앞에서 작성한 <strong>extend()</strong> 함수는 프로퍼티의 이름과 값 외에 프로퍼티가 가진 속성은 복사되지 않는다.<br>뿐만 아니라, 접근자 프로퍼티의 getter/setter 메서드도 복사하지 않는다.<br>대신 getter/setter 메서드를 정적 데이터 프로퍼티로 바꾼다.<br>Object.getOwnPropertyDescriptor()와 Object.defineProperty()를 이용해 속성 까지 복사해보자.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,      <span class="comment">//Object.prototype 에</span></span><br><span class="line">                      <span class="string">"extend"</span>,              <span class="comment">//extend 추가</span></span><br><span class="line">                      &#123; <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">                        enumerable: <span class="literal">false</span>,   <span class="comment">//열거 불가능</span></span><br><span class="line">                        configurable: <span class="literal">true</span>,</span><br><span class="line">                        value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123; <span class="comment">//extend의 값은 함수다</span></span><br><span class="line">                            <span class="comment">//열거되지 않은 프로퍼티들을 포함한 모든 고유 프로퍼티에 대해</span></span><br><span class="line">                            <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">                                <span class="comment">//this 객체에 이미 같은 이름의 프로퍼티가 존재하면 건너뜀</span></span><br><span class="line">                                <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="comment">//객체 o에 프로퍼티 디스크립터를 가져옴</span></span><br><span class="line">                                <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o.names[i]);</span><br><span class="line">                                <span class="comment">//this 객체에 프로퍼티를 생성할 때 앞에서 가져온 디스크립터 객체를 추가</span></span><br><span class="line">                                <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Getter-Setter-메서드를-지원하는-레거시-API"><a href="#Getter-Setter-메서드를-지원하는-레거시-API" class="headerlink" title="- Getter/Setter 메서드를 지원하는 레거시 API"></a>- Getter/Setter 메서드를 지원하는 레거시 API</h2><p>객체 리터럴 문법을 사용하면 새 객체를 만들 때 접근자 프로퍼티를 정의 할 수는 있지만,<br>getter/setter 메서드의 존재 여부를 검사하거나 기존 객체에 새 접근자 프로퍼티를 추가할 수 없다.<br>ECMAScript5 에서는 Object.getOwnPropertyDescriptor()와 Object.defineProperty()를 이용해 그런 일들을 할 수 있다.</p>
<p>대다수 브라우저에 내장된 자바스크립트 엔진에서는 ECMAScript5가 나오기 전부터 객체 리터럴에 get/set 문법을 지원했다.<br>이 엔진들은 getter/setter 메서드를 검사하고 설정하는 비표준 레거시 API를 지원한다.<br>이 API에는 네 개의 메서드가 있고, 모든 객체에서 사용할 수 있다.<br>이들 중 __lookupGetter__()와 __lookupSetter__()는 각각 해당 프로퍼티에 설정된 getter/setter 메서드를 <strong>반환</strong>한다.</p>
<p>그리고 __defineGetter__()와 __defineSetter__()는 각각 getter/setter 메서드를 <strong>정의</strong>한다.<br>이떄 첫 번째 인자로 <strong>프로퍼티 이름</strong>을, 두 번째 인자로 <strong>getter/setter</strong> 메서드를 넘긴다.</p>
<blockquote>
<p>__defineGetter__(프로퍼티 이름, getter 메서드), __defineSetter__(프로퍼티 이름, setter 메서드)</p>
</blockquote>
<p>API의 메서드 이름의 시작과 끝에 <code>__</code>가 붙는데, 이는 메서드가 표준이 아니라는 것을 말한다.<br><br><br><br></p>
<h1 id="객체-속성"><a href="#객체-속성" class="headerlink" title="객체 속성"></a>객체 속성</h1><p>모든 객체는 prototype, class, extensible 속성을 가지고 있다.<br><br></p>
<h2 id="prototype-속성"><a href="#prototype-속성" class="headerlink" title="- prototype 속성"></a>- prototype 속성</h2><p>객체의 prototype 속성은 프로퍼티를 <strong>상속</strong>하는 객체를 지정한다.<br>보통 이 속성은 ‘객체 o의 프로토타입 속성’이 아닌 ‘객체 o의 프로토타입’이라고 할 정도로 중요하다.</p>
<p>prototype 속성은 객체가 만들어지는 시점에 설정된다.<br>객체 리터럴을 통해 만든 객체는 <strong>Object.prototype</strong>을 객체의 프로토타입으로 설정한다.<br><code>new</code>를 사용해 만든 객체는 생성자 함수의 <code>prototype</code> 프로퍼티 값이 prototype 속성의 값이 되고,<br>Object.create() 메서드로 만든 객체는 메서드의 첫 번째 인자가 프로토타입 속성의 값이 된다.</p>
<p>ECMAScript5 에서는 <strong>Object.getPrototypeOf()</strong>에 객체를 전달해 객체의 프로토타입을 검사할 수 있다.<br>ECMAScript3 에는 <strong>Object.getPrototypeOf()</strong>와 같은 메서드가 없지만, 객체 o의 프로토타입을 검사하기 위해 <strong>o.constructor.prototype</strong> 표현식을 사용할 수 있다.</p>
<p><code>new</code> 표현식으로 생성된 객체는,<br> 일반적으로 객체를 만드는 데 사용되는 생성자 함수를 참조하는 ‘constructor 프로퍼티’를 상속받는다.<br> 생성자 함수는 생성자를 사용해 만든 객체의 프로토타입을 <code>prototype</code> 프로퍼티로 갖는다.</p>
<p> 객체 리터럴이나 Object.create()로 생성된 객체는 Object() 생성자를 constructor 프로퍼티로 갖는다.<br> 따라서 constructor.prototype 은 객체 리터럴에 대해서는 정확한 프로토타입을 참조하지만<br> Object.create()로 생성된 객체의 경우 그렇지 않다.</p>
<p> 객체 A가 객체 B의 프로토타입(또는 프로토타입 체인의 일부)인지 확인하기 위해 <strong>isPrototypeOf()</strong> 메서드를 사용한다.<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;                     <span class="comment">//객체 p</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);          <span class="comment">//객체 p를 프로토타입으로 하는 객체 o</span></span><br><span class="line">p.isPrototype(o);                  <span class="comment">//true; 객체 o는 객체 p를 상속받음</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototype(p);   <span class="comment">//true; 객체 p는 Object.prototype을 상속받음</span></span><br></pre></td></tr></table></figure></p>
<p><strong>isPrototype()</strong> 함수는 <code>instanceof</code> 연산자와 비슷한 동작을 한다.</p>
<p>넷스케이프 초기 버전부터 모질라의 자바스크립트 엔진은 prototype 속성을 <strong>__proto__</strong> 프로퍼티를 통해 노출하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// &#123;x:1&#125;</span></span><br><span class="line">   <span class="comment">//  __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>이 프로퍼티를 사용해 객체의 프로토타입을 직접 검사하고 수정할 수 있다.<br><strong>__proto__</strong> 프로퍼티를 사용하면 이식성이 떨어진다.<br>사파리와 크롬에서는 지원하지만, IE와 오페라에는 구현되지 않았다.<br>ECMAScript5 가 구현된 파이어폭스 버전은 <strong>__proto__</strong> 프로퍼티를 지원하지만,<br>객체가 확장 불가능할 경우에는 프로토타입을 변경할 수 없다.<br><br></p>
<h2 id="class-속성"><a href="#class-속성" class="headerlink" title="- class 속성"></a>- class 속성</h2><p>객체의 class 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다.<br>ECMAScript 모두 어떠한 방법으로도 이 속성을 변경할 수 없고,<br>그 값을 질의하는 것도 아주 간접적으로만 가능하다.<br>Object.prototype 으로부터 상속되는 기본 toString() 메서드는 객체의 타입을 아래 형태의 문자열로 반화한다.</p>
<blockquote>
<p>[object class]</p>
</blockquote>
<p>따라서 <strong>객체의 클래스 정보</strong>를 알아보기 위해서는 <strong>객체의 toString()</strong> 메서드를 호출하면 된다.<br>이때 반환되는 스트링의 아홉 번째 문자부터 문자열 끝에서 두번째 문자까지 추출한다.<br>그런데 주의할 점은 많은 객체들이 좀 더 유용한, 다른 toString() 을 상속받는다는 점이다.<br>따라서 원하는 toString() 메서드를 호출하기 위해서는 <strong>Function.call()</strong> 메서드를 사용해 간접적으로 호출해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 전달된 객체가 null 이나 undefined 인 경우 return</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이 함수에는 어떠한 자바스크립트 값을 넣어도 동작한다.<br>숫자, 문자, 불리언 값은 toString() 메서드를 호출할 때 객체처럼 동작한다.<br>위에서는 null과 undefined에 대해 따로 처리를 했지만, ECMAScript5는 처리할 필요가 없다.</p>
<p>Array나 Date와 같이 내장 생성자를 통해 생성된 객체는 생성자의 이름을 딴 class 속성을 가지고 있다.<br>호스트 객체도 객체의 구현에 따라 다르지만 일반적으로 의미있는 class 속성을 갖는다.<br>객체 리터럴이나 Object.create()를 사용해 생성된 객체의 class 속성값은 ‘Object’다.<br>생성자 함수를 임의로 정의하고 객체를 만들더라도 class 속성 값은 ‘Object’가 되고, 다른 값으로 바꿀 수 없다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">classof(<span class="literal">null</span>);          <span class="comment">//"Null";</span></span><br><span class="line">classof(<span class="number">1</span>);             <span class="comment">//"Number";</span></span><br><span class="line">classof(<span class="string">""</span>);            <span class="comment">//"String";</span></span><br><span class="line">classof(<span class="literal">false</span>);         <span class="comment">//"Boolean";</span></span><br><span class="line">classof(&#123;&#125;);            <span class="comment">//"Object";</span></span><br><span class="line">classof([]);            <span class="comment">//"Array";</span></span><br><span class="line">classof(<span class="regexp">/./</span>);           <span class="comment">//"Regexp";</span></span><br><span class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>());    <span class="comment">//"Date";</span></span><br><span class="line">classof(<span class="built_in">window</span>);        <span class="comment">//"Window" (클라이언트 측 호스트 객체);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; &#125;;        <span class="comment">//생성자 함수 생성</span></span><br><span class="line">classof(<span class="keyword">new</span> f());       <span class="comment">//"Object";</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="extensible-속성"><a href="#extensible-속성" class="headerlink" title="- extensible 속성"></a>- extensible 속성</h2><p>객체의 <strong>extensible</strong> 속성은 객체에 새 프로퍼티를 추가할 수 있는지 여부를 결정한다.</p>
<p>ECMAScript3 에서는 모든 내장 객체와 사용자 정의 객체는 특별한 경우가 아니면 확장할 수 있고,<br>호스트 객체의 확장성은 구현체에 따라 다르다.</p>
<p>ECMAScript5 에서는 모든 내장 객체와 사용자 정의 객체는 확장할 수 없게 바뀌지 않는한 확장할 수 있고,<br>호스트 객체의 확장성은 구현체에 따라 다르다.</p>
<p>ECMAScript5 에는 객체의 확장 여부를 검사하고 설정하는 함수들이 정의되어 있다.<br>확장할 수 있는 객채 인지 알아보려면 <strong>Object.isExtensible()</strong> 함수에 해당 객체를 인자로 넘긴다.</p>
<blockquote>
<p>Object.isExtensible(확장 여부를 확인할 객체)</p>
</blockquote>
<p>객체를 확장할 수 없도록 하려면, <strong>Object.preventExtensions()</strong>에 해당 객체를 인자로 넘긴다.</p>
<blockquote>
<p>Object.preventExtensions(확장할 수 없게할 객체)</p>
</blockquote>
<p>Object.preventExtensions() 함수를 사용해 객체를 확장할 수 없도록 설정하면, 설정하기 전 상태로 돌아갈 수 없다.<br>또한 오직 해당 객체의 <strong>extensible</strong> 속성 값만 변경한다.<br>extensible 속성이 false 인 객체라고 해도, 프로토타입에 새 프로퍼티를 추가하면, 추가된 프로퍼티는 해당 객체에 상속된다.</p>
<p><strong>extensible</strong> 속성의 목적은 <strong>‘잠겨있는’ 객체의 상태를 고정</strong>하고, <strong>외부에서 변경하는 것을 막는 것</strong>이다.<br>객체의 extensible 속성은 종종 configurable 속성과 writable 속성과 함께 사용되는데,<br>ECMAScript5 에서는 이들 속성을 좀 더 쉽게 다루기 위해 몇 가지 함수를 정의하고 있다.</p>
<p><strong>Object.seal()</strong>은 Object.preventExtensions()와 동작이 유사하지만,<br>객체를 확장할 수 없게 만들 뿐만 아니라, 객체가 가진 모든 고유 프로퍼티를 설정 불가능하게 만든다.<br>즉, 객체에 새로운 프로퍼티를 추가할 수 없고, 기존 프로퍼티의 설정을 바꾸거나 지울 수도 없다.<br>하지만 writable 속성이 true인 기존 프로퍼티의 값은 변경할 수 있다.<br>Object.seal() 메서드로 한번 ‘봉인’된 객체는 다시 해제할 수 없다.<br><strong>Object.isSeal()</strong> 메서드를 사용해 객체가 봉인되어 있는지 검사할 수 있다.</p>
<p><strong>Object.freeze()</strong> 메서드는 객체를 좀 더 단단히 잠근다.<br>객체를 확장할 수 없게 만들고 프로퍼티 설정을 바꿀 수 없게 바꾼다.<br>그리고 객체가 가진 고유 프로퍼티를 전부 <strong>읽기 전용</strong>으로 만든다.<br>(객체가 접근자 프로퍼티로 setter 메서드를 가지고 있다면, 읽기 전용으로 바뀐 프로퍼티도 setter 메서드를 이용해 변경할 수 있다.)<br><strong>Object.isFreeze()</strong> 메서드를 사용하면 객체가 ‘단단히 잠겨있는지’ 확인할 수 있다.</p>
<p><strong>Object.seal()</strong>과 <strong>Object.freeze()</strong> 는 주어진 객체의 고유 프로퍼티에만 영향을 미치고,<br>객체가 가진 프로토타입 객체에는 영향을 미치지 않는다.<br>객체를 철저히 잠그고 싶다면, 객체의 프로토타입 체인까지 잠궈야 한다.</p>
<p>Object.preventExtensions(), Object.seal(), Object.freeze() 메서드들은 인자로 넘겼던 객체를 다시 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object.freeze()로 프로토타입을 고정</span></span><br><span class="line"><span class="comment">//열거할 수 없는 프로퍼티 y를 가진 객체를 Object.seal()로 봉인</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(</span><br><span class="line">            <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.freeze(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;), &#123;<span class="attr">y</span>: &#123;<span class="attr">value</span>:<span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="객체-직렬화하기"><a href="#객체-직렬화하기" class="headerlink" title="객체 직렬화하기"></a>객체 직렬화하기</h1><p>객체 직렬화는 객체의 상태를 문자열로 변환하는 과정을 말한다.<br>이때 생성된 문자열은 나중에 객체 복원에 사용할 수 있다.</p>
<p>ECMAScript5 는 자바스크립트 <strong>객체를 직렬화</strong>하는 <strong>JSON.stringify()</strong> 메서드와<br>직렬화한 문자열을 <strong>객체로 복원</strong>하는 <strong>JSON.parse()</strong> 메서드를 지원한다.<br>이 두 함수는 JSON 데이터 교환 형식을 사용한다.<br>(JSON은 ‘JavaScript Object Notation’의 줄임 표현이며, 자바스크립트 객체 리터럴이나 배열 리터럴의 문법과 유사함)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:&#123;<span class="attr">z</span>:[<span class="literal">false</span>,<span class="literal">null</span>,<span class="string">""</span>]&#125;&#125;;   <span class="comment">//테스트용 객체를 정의</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(o);              <span class="comment">//s는 '&#123;'x':1,'y':&#123;'z':[false,null,'']&#125;&#125;' 문자열</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">JSON</span>.parse(s);                  <span class="comment">//p는 객체 o를 복사한 객체</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript3 에서도 <em>json2.js</em> 모듈을 사용하면 두 함수를 사용할 수 있다.</p>
<p>JSON 문법은 자바스크립트 문법의 부분 집합이기 때문에,<br>자바스크립트의 모든 값을 표현할 수는 없다.<br>객체와 배열, 문자열, 유한한 수, true, false, null은 모두 직렬화할 수 있고, 반대로 복원할 수 있다.<br>NaN(Not a Number)와 Infinity, -Infinity는 null로 직렬화된다.</p>
<p>Date 객체는 ISO 날짜 형식을 따르는 문자열로 직렬화된다. (Date.toJSON() 참고)<br>하지만 <strong>JSON.parse()</strong> 메서드는 문자열을 Date 객체로 복원하지 않는다.</p>
<p>Function, RegExp, Error 객체와 undefined 값은 직렬화하거나 복원할 수 없다.</p>
<p><strong>JSON.stringify()</strong> 메서드는 <strong>객체가 가진 열거가능한 고유 프로퍼티만 직렬화</strong> 한다.<br>만약, 어떤 프로퍼티 값을 직렬화할 수 없다면, 해당 프로퍼티 값은 직렬화 결과에 포함되지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.stringify(a);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">JSON</span>.parse(b);</span><br><span class="line">c;  <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>JSON.stringify()</strong>와 <strong>JSON.parse()</strong> 함수는 두 번째 선택인자를 갖는다.<br>이 인자를 사용해 직렬화 또는 복원할 프로퍼티 목록을 <strong>지정</strong>할 수 있다.<br>직렬화하거나 문자열로 바꾸는 과정에서 특정 프로퍼티의 값을 바꿀 수도 있다.</p>
<blockquote>
<p>JSON.stringify(직렬화할 객체, 직렬화할 프로퍼티 목록)<br>JSON.parse(복원할 객체, 복원할 프로퍼티 목록)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.stringify(a, [<span class="string">"x"</span>,<span class="string">"y"</span>]);</span><br><span class="line">b;  <span class="comment">//'&#123;'x':1,'y':2&#125;'</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="객체-메서드"><a href="#객체-메서드" class="headerlink" title="객체 메서드"></a>객체 메서드</h1><p>모든 자바스크립트 객체는(명시적으로 프로토타입이 없이 생선된 객체는 제외) <strong>Object.prototype</strong>의 프로퍼티를 상속받는다.<br>이처럼 상속된 프로퍼티들은 대부분 메서드이고, 어느 객체에서 사용할 수 있기 때문에 주요 메서드라 할 수 있다.<br><br></p>
<h2 id="toString-메서드"><a href="#toString-메서드" class="headerlink" title="- toString() 메서드"></a>- toString() 메서드</h2><p><strong>toString()</strong> 메서드는 어떠한 인자도 받지않고, 호출 대상 객체의 값을 어떠한 방식으로든 문자열로 만들어 반환한다.<br>자바스크립트는 객체를 문자열로 반환해야 할 때 항상 <strong>toString()</strong> 메서드를 사용한다.</p>
<p>예를 들어, <code>+</code> 연산자를 사용해 문자열과 객체를 연결하려 하거나 문자열을 인자로 받는 메서드에 객체를 전달하면,<br>해당 객체의 toString() 메서드가 호출되어 문자열 변환 작업이 실행된다.</p>
<p>기본적으로 구현된 toString() 메서드가 제공하는 정보는 그다지 유용하지 않다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line">s.toString();   <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure></p>
<p>이처럼 기본으로 주어진 메서드가 그다지 유용한 정보를 제공하지 않기 때문에,<br>많은 클래스가 고유한 toString() 메서드를 정의한다.</p>
<p>예를 들어, 배열을 문자열로 변환하면, 배열의 각 원소를 문자열로 변환한 후 연결한 문자열을 얻는다.<br>함수를 문자열로 변환하면 함수의 소스 코드를 얻을 수 있다.<br><br></p>
<h2 id="toLocaleString-메서드"><a href="#toLocaleString-메서드" class="headerlink" title="- toLocaleString() 메서드"></a>- toLocaleString() 메서드</h2><p>toString() 메서드 외에도 모든 객체는 <strong>toLocaleString()</strong> 메서드를 갖고 있다.<br>이 메서드는 객체의 지역화(localized)된 문자열 표현을 반환한다.</p>
<p>객체에 기본으로 정의된 <strong>toLocaleString()</strong> 메서드는 그 자체로 어떠한 지역화 작업을 하지 않는다.<br>단순히 toString()을 호출한 결과를 반환한다.</p>
<p>Date와 Number 클래스는 숫자와 날짜, 시간의 지역화된 형식을 출력하기 위해 맞춤형 <strong>toLocaleString()</strong> 을 정의하고 있다.</p>
<p>배열에 정의된 <strong>toLocaleString()</strong> 메서드는 toString()과 동일하게 작동하지만<br>각 배열 원소의 <strong>toLocaleString()</strong> 메서드를 호출한다는 점이 다르다.<br><br></p>
<h2 id="toJSON-메서드"><a href="#toJSON-메서드" class="headerlink" title="- toJSON() 메서드"></a>- toJSON() 메서드</h2><p>Object.prototype에는 <strong>toJSON()</strong> 메서드가 정의되어 있지 않다.<br>하지만 JSON.stringify() 메서드는, 직렬화할 객체에 <strong>toJSON()</strong> 메서드가 있는지 찾는다.<br>만약 직렬화하려는 객체에 <strong>toJSON()</strong> 메서드가 있으면, <strong>toJSON()</strong> 메서드가 호출되고<br>그 결과 값이 원래 객체 대신 직렬화된다.<br><br></p>
<h2 id="valueOf-메서드"><a href="#valueOf-메서드" class="headerlink" title="- valueOf() 메서드"></a>- valueOf() 메서드</h2><p><strong>valueOf()</strong> 메서드는 toString() 메서드와 매우 유사하다.<br>하지만 이 메서드는 자바스크립트가 객체를 숫자와 같은 다른 원시 타입으로 변환하려 할 떄 호출된다.<br>즉, 객체가 원시 타입 값을 필요로 하는 문맥 안에서 사용될 때,<br>자바스크립트는 <strong>valueOf()</strong> 메서드를 자동으로 호출한다.<br>객체에 기본으로 정의된 <strong>valueOf()</strong> 메서드는 아무런 변환 작업을 하지 않는다.<br>하지만 몇몇 내장 객체들은 자신만의 <strong>valueOf()</strong> 메서드를 정의한다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/circleGiven" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/in/wonjune/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-03-23T14:18:47.409Z"><meta itemprop="articleBody" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다.
프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열을 값에 대응시키는 구조라고 할 수 있다.이런 대응관계는 많은..."><meta itemprop="url" content="http://yoursite.com/2018/02/16/javascript-object/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/02/16/javascript-object/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/10/javascript-statement/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 문장</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/08/javascript-type/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 타입, 값, 변수</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/09/null-undefined/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript&gt;&gt; null vs undefined</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/03/27/javascript-function/">Javascript | 함수</a></li><li class="recent-posts__item"><a href="/2018/03/24/book-javascript-guide/">Book | 자바스크립트 완벽 가이드</a></li><li class="recent-posts__item"><a href="/2018/03/11/javascript-summary/">javascript-summary</a></li><li class="recent-posts__item"><a href="/2018/03/10/javascript-array/">Javascript | 배열</a></li><li class="recent-posts__item"><a href="/2018/03/06/web-was-difference/">Server | Web server 와 Application server</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Basic/">Basic</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program/">Program</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Program/SICP/">SICP</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Speech/">Speech</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>