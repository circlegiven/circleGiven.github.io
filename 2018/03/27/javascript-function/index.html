<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 함수 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/03/27/javascript-function/"/>
<meta name="description" content="함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.함수 정의에는 매개변수(parameter), 또는 형식인자라고 불리는 식별자 목록이 포함될 수 있는데, 이 매개변수는 함수 몸체 내에서…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 함수">
<meta property="og:url" content="http://yoursite.com/2018/03/27/javascript-function/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.함수 정의에는 매개변수(parameter), 또는 형식인자라고 불리는 식별자 목록이 포함될 수 있는데, 이 매개변수는 함수 몸체 내에서…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-04-19T15:29:21.604Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 함수">
<meta name="twitter:description" content="함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.함수 정의에는 매개변수(parameter), 또는 형식인자라고 불리는 식별자 목록이 포함될 수 있는데, 이 매개변수는 함수 몸체 내에서…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-03-27 00:19:42"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 함수</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-03-26T15:19:42.000Z" itemprop="datePublished">2018-03-27 00:19:42</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Javascript/">Javascript</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Javascript/Basic/">Basic</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p>함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.<br>함수 정의에는 <strong>매개변수(parameter)</strong>, 또는 형식인자라고 불리는 식별자 목록이 포함될 수 있는데, 이 매개변수는 함수 몸체 내에서 지역 변수처럼 취급된다.<br>함수 호출시 에는 함수의 매개변수에게 값, 즉 <strong>실인자(arguments)</strong>들을 제공한다.<br>(즉, 함수 정의시에 사용되는 <strong>매개변수</strong>는 호출시에는 <strong>실인자</strong>로 불리운다)<br>대개 함수는 반환 값을 계산하는 과정에서 이 <strong>실인자</strong>, 즉, <strong>전달인자</strong> 값을 사용하며,<br>이 반환 값은 함수 호출 표현식의 결과 값이 된다.</p>
<p>각 호출에는 전달인자 외에도 <strong>호출 컨텍스트(invocation context)</strong>가 포함되는데, <code>this</code> 키워드의 값이 바로 해당 <strong>컨텍스트</strong>다.<br>어떤 함수가 객체를 대상으로, 또는 객체를 통해서 호출하면, 이 객체는 해당 함수의 <strong>호출 컨텍스트</strong>, 즉 호출된 함수의 <code>this</code> 값이 된다.</p>
<p>어떤 <strong>객체의 프로퍼티로 할당된 함수를 해당 객체의 메서드</strong>라 한다.</p>
<p><strong>새로 생성된 객체를 초기화하는 데 쓰이는 함수는 생성자(constructor)</strong>라고 한다.</p>
<p>자바스크립트에서 함수는 객체이고 프로그램 안에서 조작할 수 있다.<br>이를테면 자바스크립트는 함수를 변수에 할당할 수 있고, 다른 함수에 인자로 전달할 수도 있다.<br>함수는 객체이기 때문에, 프로퍼티를 지정할 수 있고 심지어 함수의 메서드를 호출할 수도 있다.</p>
<p>자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있고, 중첩된 함수는 해당 함수가 정의된 유효범위 안의 어떤 변수에도 접근할 수 있다.<br>이는 자바스크립트 함수가 <strong>클로저(closure)</strong>이며, 클로저가 가능하게 하는 중요하고 강력한 프로그래밍 기법을 자바스크립트도 구사할 수 있음을 뜻한다.<br><br><br><br></p>
<h1 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h1><p>함수는 <code>function</code> 키둬드에 의해 정의되며, <code>function</code> 키워드는 <strong>함수 정의 표현식</strong> 또는 <strong>함수 선언문</strong>에서 사용된다.<br>두 경우 모두, 함수 정의는 <code>function</code> 키워드로 시작하고, 그 뒤에 다음과 같은 구성요소들이 따라온다.</p>
<ul>
<li><strong>함수 이름 식별자</strong><br>함수 이름은 <strong>함수 선언문</strong>에서는 반드시 필요하다.<br>함수 이름은 곧 변수이며, 새로 정의된 함수 객체는 그 변수에 할당된다.<br><strong>함수 정의 표현식</strong>에서는 이름을 생략할 수 있다. 그러나 만일 이름을 표기했다면, 그 이름은 해당 함수 몸체 안에서만 참조할 수 있다.</li>
<li><strong>쉼표로 구분된 0개 이상의 식별자들과, 이 식별자 들을 둘러싼 한쌍의 괄호</strong><br>이 식별자들은 함수의 <strong>매개변수(parameter)</strong>, 즉 형식인자들의 이름이고, 함수 몸체 내에서 지역 변수처럼 취급된다.</li>
<li><strong>0개 이상의 자바스크립트 문장을 포함하는 한 쌍의 중괄호</strong><br>이 자바스크립트 문장들은 함수가 호출될 때마다 실행되는 함수의 본문이다.<br>함수에서 중괄호는 <strong>함수 스코프</strong>라 불리운다.</li>
</ul>
<p><br></p>
<h2 id="함수-선언문-Function-declaration"><a href="#함수-선언문-Function-declaration" class="headerlink" title="- 함수 선언문 Function declaration"></a>- 함수 선언문 Function declaration</h2><p><strong>함수 선언문</strong>에는 함수 이름이 반드시 필요하다.<br>함수 선언문은 변수를 정의하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printProps</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p + <span class="string">": "</span> + o[p] + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>함수를 호출하려면 먼저 호출할 함수를 참조할 수 있어야된다.</strong><br><strong>함수 선언문</strong>은 그 함수를 둘러싼 스크립트 맨 위나, 함수 내부의 맨 위로 <strong>‘끌어올려(hoisted)’</strong>진다.<br>따라서 해당 함수는 이 함수가 정의된 위치보다 앞서 나오는 코드로부터 호출될 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">printTest();  <span class="comment">// "test"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>함수 선언문</strong>이 실제로 하는 일은, 어떤 변수를 정의하고 함수 객체를 그 변수에 할당하는 것이다.<br>위에서는 printTest라는 변수를 정의함과 동시에 함수 객체를 할당한 것이다.<br><br></p>
<h2 id="함수-정의-표현식-Function-expression"><a href="#함수-정의-표현식-Function-expression" class="headerlink" title="- 함수 정의 표현식 Function expression"></a>- 함수 정의 표현식 Function expression</h2><p><strong>함수 정의 표현식</strong>은 어떤 <strong>변수를 정의</strong>하고 함수 객체를 그 <strong>변수에 할당</strong>한다.<br>함수 정의 표현식에서 함수 이름은 옵션이다.<br>함수 정의 표현식 방법에는 기명과 익명 두 가지가 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의 표현식 (익명)</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의 표현식 (기명)</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * fact(x<span class="number">-1</span>);   <span class="comment">// 이름을 표시한 함수 정의 표현식이 재귀호출에 사용되었다</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>함수 정의 표현식</strong>은 실제로 변수를 정의하지는 않는다.</p>
<p>위처럼 fact 함수와 같이 함수 자신을 참조할 필요가 있을 떄 함수에 이름을 붙일 수 있다.<br><strong>함수 정의 표현식</strong>이 이름을 포함하면, 이 함수 몸체의 유효 범위에 해당 함수 객체에 연결된 이름이 포함된다.<br>즉, 사실상 그 함수 이름이 해당 함수의 지역 변수가 되는 것이다.<br>표현식의 형태로 정의된 함수 대부분은 이름이 필요하지 않는다.<br>표현식 형태로 함수를 정의하는 것은 한 번만 사용되는 함수에 특히 적합하다.</p>
<p><strong>함수를 호출하려면 먼저 호출할 함수를 참조할 수 있어야된다.</strong><br><strong>함수 정의 표현식</strong>은 변수에 할당되기 전까지 함수를 참조할 수 없다.<br>변수 선언은 끌어올려지지만, 변수 할당은 끌어올려지지 않는다.<br>그래서 함수 정의 표현식으로 정의된 함수는 정의되는 지점 위에서는 호출할 수 없다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">printTest();   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의 표현식 (익명)</span></span><br><span class="line"><span class="keyword">var</span> printTest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br>함수 대부분은 <code>return</code> 문을 포함하고 있다.<br><code>return</code> 문은 함수 <strong>실행을 중단</strong>하고, <code>return</code> 다음에 오는 표현식의 값을 호출자에게 <strong>반환</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 표현식;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); <span class="comment">// 표현식</span></span><br></pre></td></tr></table></figure></p>
<p><code>return</code> 다음에 오는 표현식이 없다면 <strong>undefined</strong> 값을 반환한다.<br>만약 함수가 <code>return</code> 문을 포함하지 않는다면, 함수 몸체 내의 각 구문이 실행된 다음 호출자에게 <strong>undefined</strong> 값을 반환한다.<br>(return 값이 없는 함수를 가끔 <strong>프로시저(procedure)</strong>라고 부르기도 한다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return 문 있는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 문 없는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(); <span class="comment">// undefined</span></span><br><span class="line">test2(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="중첩-함수"><a href="#중첩-함수" class="headerlink" title="- 중첩 함수"></a>- 중첩 함수</h2><p>자바스크립트에서 함수는 다른 함수와 <strong>중첩</strong>될 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(square(a) + square(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>중첩 함수의 흥미로운 점은, <strong>유효범위(scope)</strong> 규칙이다.<br>중첩된 함수는 해당 함수가 속한 함수의 매개변수와 변수에 접근할 수 있다.<br>위 코드로 예를 들면,<br>안쪽 함수 square()는 바깥쪽 함수 hypotenuse()에 정의된 매개변수 a와 b를 읽고 쓸 수 있다.<br>이러한 중첩 함수의 유효범위 규칙은 매우 중요하다.</p>
<p>함수 선언문은 진짜 문장이 아니다.<br>그리고 <em>ECMAScript</em> 는 함수 선언문을 최상위 레벨에만 두도록 규정한다.<br><strong>함수 선언문</strong>은 전역 코드 혹은 다른 함수 안에서 등장할 수 있지만, 반복문 내부, 조건문, try/catch/finally 또는 with문 안에는 들어갈 수 없다.<br>(몇몇 자바스크립트 구현체는 이 규칙이 완회되었다)<br>이런 제한은 문장으로 선언되는 함수에만 적용된다. <strong>함수 정의 표현식</strong>은 자바스크립트 코드 어디에나 사용할 수 있다.<br><br><br><br></p>
<h1 id="함수-호출하기"><a href="#함수-호출하기" class="headerlink" title="함수 호출하기"></a>함수 호출하기</h1><p>함수를 정의했더라도 함수 몸체의 자바스크립트 코드는 함수를 호출하지 않으면 실행되지 않는다.<br>자바스크립트 함수는 네 가지 방법으로 호출할 수 있다.</p>
<ul>
<li>일반적인 함수 형태</li>
<li>메서드 형태</li>
<li>생성자</li>
<li>call()과 apply() 메서드를 통한 간접 호출</li>
</ul>
<p><br></p>
<h2 id="함수-호출"><a href="#함수-호출" class="headerlink" title="- 함수 호출"></a>- 함수 호출</h2><p>함수는 <strong>일반적인 함수 형태</strong>로 호출되거나 호출 표현식과 함께 <strong>메서드 형태</strong>로 호출된다.<br><strong>호출 표현식</strong>은 함수 객체로 평가되는 함수 표현식과, 여는 괄호(<code>{</code>), 콤마(<code>,</code>)로 구분된 0개 이상의 전달인자 표현식, 그리고 닫는 괄호(<code>}</code>)로 구성된다.<br>이때 함수 표현식이 프로퍼티 접근 표현식(함수가 어떤 객체의 프로퍼티이거나 어떤 배열의 요소인 경우)이면 이는 <strong>메서드 호출 표현식</strong>이다.</p>
<p>우선, 다음 코드는 일반적인 함수 호출 표현식 몇 가지를 포함하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printprops(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> total = distance(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>) + distance(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> probability = factorial(<span class="number">5</span>) / factorial(<span class="number">13</span>);</span><br></pre></td></tr></table></figure></p>
<p>함수가 호출될 때<br>먼저, 괄호 사이에 있는 각각의 전달인자 표현식이 평가되고(evaluated), 평가 결과 값이 해당 함수의 <strong>전달인자</strong>가 된다.<br>이 전달인자 값들은 함수 정의에 등장하는 <strong>형식인자(파라메터)</strong> 각각에 대응된다.<br>함수 몸체에서 형식인자는 실인자의 값으로 평가된다.</p>
<p>일반적인 함수 호출에서 호출 표현식의 값은 그 함수의 반환 값이다.<br>만약 인터프리터가 <code>return</code>문을 만나지 못해 함수 끝에 다다르면, 그 반환 값은 <strong>undefined</strong>가 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>인터프리터가 <code>return</code>문을 실행하여 함수가 반환되면 반환 값은 <code>return</code> 다음에 나오는 표현식의 값이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// "test"</span></span><br></pre></td></tr></table></figure></p>
<p>하지만 <code>return</code>문 다음에 아무 표현식이 없다면 반환 값은 <strong>undefined</strong>다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><em>ECMAScript 3</em>과 일반 모드(non-strict) <em>ECMAScript 5</em>의 함수 호출에서 <strong>호출 컨텍스트(this 값)</strong>는 global 객체다.<br>그러나 <em>ECMAScript 5</em> 엄격 모드에서는 <strong>호출 컨텍스트(this 값)</strong>는 <strong>undefined</strong>다.</p>
<p>일반적인 함수 형태로 호출하도록 작성된 함수는 보통 <code>this</code> 키워드를 사용하지 않는다.<br>그러나 이 <code>this</code> 키워드를, 엄격 모드(strict mode)가 적용되었는지를 판단하기 위해 사용할 수는 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 엄격 모드 여부를 알아내기 위한 함수를 정의하고 호출</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="메서드-호출"><a href="#메서드-호출" class="headerlink" title="- 메서드 호출"></a>- 메서드 호출</h2><p>메서드는 객체의 속성으로 저장된 자바스크립트 <strong>함수</strong>일 뿐이다.<br>만약 함수 f와 객체 o가 있다면, 이름인 m인 메서드는 다음과 같이 정의할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 o에 함수 f를 메서드 m으로 정의</span></span><br><span class="line">o.m = f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 o의 메서드 m을 호출</span></span><br><span class="line">o.m();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 메서드 m이 두 개의 전달인자를 받는다면</span></span><br><span class="line">o.m(x, y);</span><br></pre></td></tr></table></figure></p>
<p>앞의 코드는 함수표현식(o.m)과 두 전달인자에 대한 표현식(x,y)으로 구성된 호출표현식이다.<br>여기서 함수 표현식 자체는 <strong>프로퍼티 접근 표현식</strong>이고, 이는 이 함수가 일반 함수 형태가 아니라 <strong>메서드 형태</strong>로 호출됨을 뜻한다.</p>
<p>메서드 호출의 전달인자와 반환 값에 대한 규칙은 일반 함수 호출의 경우와 완전히 같다.<br>그러나 메서드 호출은 함수 호출에 비해 한 가지 중요한 부분이 다른데, 그것은 바로 <strong>호출 컨텍스트</strong>다.<br>프로퍼티 접근 표현식은 객체와 프로퍼티 이름으로 구성되어 있다.<br>위 메서드 호출 표현식에서는 객체 o가 호출 컨텍스트가 되므로, 함수 몸체에서 <code>this</code> 키워드를 사용해서 객체 o를 참조할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">    operand1: <span class="number">1</span>,</span><br><span class="line">    operand2: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 이 객체 calculator를 참조하기 위해 this 키워드를 사용</span></span><br><span class="line">        <span class="comment">// 이 객체에 result 프로퍼티를 만들고 operand1과 operand2의 합의 결과를 저장</span></span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1 + <span class="keyword">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calculator.add();   <span class="comment">// operand1 + operand2를 계산하기 위해 add 메서드 호출</span></span><br><span class="line">calculator.result;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>대부분의 메서드 호출은 프로퍼티 접근 표현식에 점(<code>.</code>)을 사용하지만, 대괄호(<code>[]</code>)를 사용해도 메서드 호출을 할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m(x,y);       <span class="comment">// .을 이용하여 메서드 호출</span></span><br><span class="line">o[<span class="string">"m"</span>](x,y);    <span class="comment">// []을 이용하여 메서드 호출</span></span><br><span class="line">o[<span class="number">0</span>](x,y);      <span class="comment">// o[0]가 메서드라면 이러한 접근도 가능하다</span></span><br></pre></td></tr></table></figure></p>
<p>또한 메서드 호출은 더 복잡한 프로퍼티 접근 표현식을 포함할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer.surname.toUpperCase(); <span class="comment">// customer.surname의 toUpperCase 메서드를 호출</span></span><br><span class="line">f().m();                        <span class="comment">// 함수 f()가 반환한 객체에 있는 메서드 m()을 호출 (메서드 체이닝)</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<blockquote>
<p><strong>메서드 체이닝 (Method Chaining)</strong><br>메서드가 객체를 반환하면, 메서드의 반환 값을 후속 호출의 일부로 사용할 수 있다.<br>이는 단일 표현식만으로 일련의(또는 ‘체인’, ‘cascade’) 메서드를 호출할 수 있게 한다.<br>예를 들면 jQuery 라이브러리를 사용할 때, 다음과 같은 코드를 흔히 보게된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모든 header를 찾고</span></span><br><span class="line"><span class="comment">// 찾은 헤더의 id에 대한 map 함수 결과를 배열로 얻고 정렬한다.</span></span><br><span class="line">$(<span class="string">":header"</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.id; &#125;).get().sort();</span><br></pre></td></tr></table></figure></p>
<p>어떤 메서드를 작성하고 있는데 특별한 반환 값이 없다면, <code>this</code>를 반환하면 어떨지 고려해보라.<br>이러한 방식을 API 전체에 일관성 있게 적용한다면, <strong>메서드 체이닝</strong>이라는 프로그래밍 스타일을 사용할 수 있게된다.<br>메서드 체이닝은 객체 이름을 한 번만 사용하고 메서드는 여러번 호출할 수 있는 방식이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape.setX(<span class="number">100</span>).setY(<span class="number">100</span>).setSize(<span class="number">50</span>).setOutline(<span class="string">"red"</span>).setFill(<span class="string">"blue"</span>).draw();</span><br></pre></td></tr></table></figure></p>
<p>단 생성자 체이닝과 메서드 체이닝은 다르다.</p>
</blockquote>
<p><br><br>메서드와 <code>this</code> 키워드는 자바스크립트 객체 지향 프로그랩밍 패러다임의 중심이다.<br>메서드로 사용되는 함수는 메서드의 호출 대상 객체를 암시적 인자로 전달받는다.<br>보통 메서드는 해당 객체에 어떤 작업을 수행하기 때문에,<br>메서드 호출 문법은 그 함수가 해당 객체에 무언가를 한다는 사실을 나타내는 세련된 방법이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width, height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure></p>
<p>두 코드는 객체 rect에 대해 완전히 같은 작업을 수행할 것이다.<br>그러나 rect.setSize 메서드가 해당 작업의 주요 초점이 객체 rect에 맞춰져 있음을 좀 더 분명하게 드러낸다.</p>
<p><code>this</code>는 키워드이며 변수나 프로퍼티 이름이 아니다.<br>자바스크립트 문법은 <code>this</code>에 값을 할당하는 것을 허용하지 않는다.<br>변수와 달리 <code>this</code> 키워드에는 <strong>유효범위(scope)</strong>가 없고, 중첩 함수는 호출자의 <code>this</code> 값을 상속하지 않는다.<br>만약 <strong>중첩 함수가 메서드 형태로 호출되면, 메서드 함수의 <code>this</code> 값은 그 함수의 호출 대상 객체</strong>다.<br>만약 <strong>중첩 함수가 함수 형태로 호출되면, 중첨 함수의 <code>this</code> 값은 global 객체(일반 모드) 또는 undefined(엄격 모드) 중 하나다.</strong></p>
<p>흔히 보는 실수는, 함수 형태로 호출된 중첩 함수가 바깥쪽(outer) 함수의 호출 컨텍스트를 획득 하기 위해 <code>this</code> 값을 사용할 수 있다고 가정하는 것이다.<br>만약 바깥쪽 함수의 <code>this</code> 값에 접근하고 싶다면, 안쪽(inner) 함수의 유효범위에 바깥쪽 함수의 <code>this</code> 값을 별도의 변수로 저장해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 o</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="comment">// 메서드 m()</span></span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;            <span class="comment">// this 값을 변수 self에 저장</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);    <span class="comment">// true: this는 객체 o이다</span></span><br><span class="line">        f();                        <span class="comment">// 함수 f()를 호출</span></span><br><span class="line">        <span class="comment">// 중첩 함수 f()</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);    <span class="comment">// false: this는 global객체 또는 undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);    <span class="comment">// true: self는 바깥쪽 함수의 this 값이다</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.m();  <span class="comment">// 객체 o의 메서드 m()을 호출</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="생성자-호출"><a href="#생성자-호출" class="headerlink" title="- 생성자 호출"></a>- 생성자 호출</h2><p>함수나 메서드 호출 앞에 <code>new</code> 키워드가 있다면, 그것은 <strong>생성자 호출</strong>이다.<br>생성자 호출은 일반 함수와 메서드 호출에 비해 매개 변수, 호출 컨텍스트와 반환 값을 다루는 방식이 다르다.</p>
<p>생성자 호출에서 괄호 안에 전달인자 목록이 포함되어 있다면, 우선 전달인자 표현식이 평가되고, 함수와 메서드 호출의 경우와 마찬가지로 평가된 전달인자가 생성자 함수에 전달된다.<br>그러나 생성자에 매개변수가 없다면, 자바스크립트 생성자 호출 문법은 전달인자 목록과 괄호를 아예 생략하는 것을 허용한다.<br>즉, 생성자 호출에서 한 쌍의 빈괄호를 언제나 생략할 수 있다는 말이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure></p>
<p>생성자를 호출하면 생성자의 prototype 프로퍼티를 상속받은 새로운 빈 객체가 생성된다.<br>생성자 함수는 객체를 초기화하고, 새로 생성된 이 객체는 생성자 함수의 호출 컨텍스트로 사용된다.<br>따라서 <strong>생성자 함수는 새로 생성된 객체를 <code>this</code> 키워드로 참조</strong>할 수 있다.<br>주의할 것은 생성자 호출이 마치 메서드 호출처럼 보일지라도, <strong>메서드가 속한 객체가 아닌 새로 생성된 객체가 호출 컨텍스트로 사용된다</strong>는 점이다.<br>즉, new o.m()과 같은 표현식에서 o가 호출 컨텍스트로 사용되지 않는다는 뜻이다.</p>
<p>생성자 함수는 보통 <code>return</code> 키워드를 사용하지 않는다.<br>일반적으로 생성자 함수는 새 객체를 초기화하고, 생성자 함수 몸체의 끝에 이르면 암시적으로 그 객체를 반환한다.<br>이 경우, 새 객체가 생성자 호출 표현식의 값이다.<br>그러나 만약 생성자가 <code>return</code>문을 사용하여 명시적으로 어떤 객체를 반환한다면, 반환된 객체가 생성자 호출 표현식의 값이 된다.<br>만약 생성자가 반환 값 없이 <code>return</code>문만 사용하거나 기본 자료형 값(primitive value)을 반환한다면, 그 반환 값은 무시되고 새로 생성된 객체가 호출 표현식의 값으로 사용된다.<br><br></p>
<h2 id="간접-호출"><a href="#간접-호출" class="headerlink" title="- 간접 호출"></a>- 간접 호출</h2><p>자바스크립트 함수는 객체이고, 모든 자바스크립트 객체와 같이 함수에도 메서드가 있다.<br>이 메서드 중 <strong>call()과 apply()는 함수를 간접적으로 호출</strong>한다.<br>두 메서드 모두 호출할 때 <code>this</code> 값을 명시적으로 지정할 수 있는데, 이는 어떤 함수든지 특정 객체의 메서드로 호출할 수 있다는 의미다.<br>심지어 함수가 실제로 그 객체에 속하지 않더라도 말이다.<br>call() 메서드는 자신에게 주어진 전달인자를 호출할 함수의 전달인자로 사용하고,<br>apply() 메서드는 값 배열을 전달인자로 사용한다.<br><br><br><br></p>
<h1 id="함수-전달인자와-매개변수"><a href="#함수-전달인자와-매개변수" class="headerlink" title="함수 전달인자와 매개변수"></a>함수 전달인자와 매개변수</h1><p>자바스크립트에서 함수를 정의할 때는 함수 매개변수의 타입, 즉 자료형을 명시하지 않는다.<br>그리고 함수를 호출할 때도, 전달하는 인자 값의 자료형을 검사하지 않는다.<br>심지어는 전달인자의 개수도 검사하지 않는다.<br><br></p>
<h1 id="생략가능한-매개변수"><a href="#생략가능한-매개변수" class="headerlink" title="- 생략가능한 매개변수"></a>- 생략가능한 매개변수</h1><p>본래 정의된 것보다 적은 수의 전달인자로 함수가 호출되면, 나머지 매개변수는 undefined 값으로 설정된다.<br>전달인자를 생략할 수 있도록 함수를 구현하면 편리할 때가 있다.<br>이를 위해서는 생략된 매개변수에 기본 값을 합리적으로 할당할 수 있어야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 o의 결거 가능한 속성에 대해 각 속성의 이름을 배열 a에 추가하고, a를 반환한다</span></span><br><span class="line"><span class="comment">// 만약 a가 생략되면 새 배열을 생성하고 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, <span class="regexp">/* optional */</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 만약 배열 a가 undefined이면 새 배열을 사용</span></span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;  <span class="comment">// a = a || []; 로 대체가능</span></span><br><span class="line">        a = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 배열 a에 객체 o의 열거가능한 프로퍼티이름을 추가</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> o) &#123;</span><br><span class="line">        a.push(propery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;   <span class="comment">// 배열 a를 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = getPropertyNames(o);    <span class="comment">// 새 배열에 o의 속성을 얻음</span></span><br><span class="line">getPropertyNames(p, a);         <span class="comment">// 객체 p의 속성을 배열 a에 추가한다.</span></span><br></pre></td></tr></table></figure></p>
<p><code>||</code> 연산자는 첫 번째 피연산자가 true이거나 true로 변환될 수 있는 값(truthy)이라면 첫 번째 피연산자를 반환하고,<br>그렇지 않으면 두 번째 피연산자를 반환한다.<br>따라서 어떤 객체가 두 번째 인자로 전달되면 함수는 그 객체를 사용할 것이다.<br>하지만, 두 번째 인자가 생략된다면(null이거나 false, false로 변환될 수 있는 값(falsy)), 새로 생성된 빈 배열이 대신 사용될 것이다.</p>
<p>생략 가능한 전달인자를 사용하여 함수를 설계할 때, 생략할 수 있는 인자는 전달ㅇ니자 목록의 제일 뒤쪽에 두어야한다.<br>함수를 호출할 프로그래머는 첫 번째 인자를 생략하고 두 번째 인자만 전달할 수는 없다.<br>굳이 하려면 첫 번째 인자를 명시적으로 undefined로 전달해야 한다.<br>함수를 정의할 때 사용한 주석 /<em> optional </em>/은, 해당 매개변수를 생략할 수 있음을 강조하기 위한 것이다.<br><br></p>
<h2 id="가변길이-전달인자-목록-Arguments-객체"><a href="#가변길이-전달인자-목록-Arguments-객체" class="headerlink" title="- 가변길이 전달인자 목록: Arguments 객체"></a>- 가변길이 전달인자 목록: Arguments 객체</h2><p>함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 인자 값을 직접적으로 참조할 방법은 없다.<br>Arguments 객체는 이러한 문제애 대한 해결책이다.<br>함수 몸체 내에서 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다.<br>Arguments 객체는 유사 배열 객체이고, 이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올 수 있다.</p>
<p>만약 전달인자 x 하나만을 받는 함수 f를 정의한다고 가정해보자.<br>만약 이 함수를 두 개의 전달인자로 호출한다면, 함수 내에서 첫 번째 전달인자는 매개변수 이름 x 또는 arguments[0]을 사용하여 접근할 수 있다.<br>두 번째 전달인자는 오직 arguments[1]을 사용해서만 접근할 수 있다.<br>게다가 실제 배열처럼 arguments도 length 프로퍼티를 가지고 있는데, 이는 arguments가 포함하고 있는 원소의 수를 나타낸다.<br>따라서 두 개의 전달인자로 호출한 함수 f의 본문 내에서 arguments.length의 값은 2이다.</p>
<p>Arguments 객체는 여러 면에서 유용하다.<br>다음은 함수가 올바른 개수의 전달인자로 호출되었는지를 확인하는 용도로 Arguments 객체를 사용하는 방법을 보여준다.<br>이러한 작업은 자바스크립트가 해주지 않기 때문에 직접 해야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 먼저 올바른 개수의 전달인자를 받았는지 확인</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length !== <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"function f called with "</span> + <span class="built_in">arguments</span>.length + <span class="string">"arguments, but it expects 3 arguments."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 실제 작업</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이렇게 전달인자의 개수를 검사하는 것은 보통 불필요하다.<br>빠진 전달인자를 undefined로 처리하고 여분의 인자는 단순히 무시하는 자바스크립트의 기본 동작은 대부분의 경우에 적합하다.</p>
<p>Arguments 객체의 한 가지 중요한 용도는 임의 개수의 전달인자를 받는 함수를 작성하는 것이다.<br>다음 예제의 함수는 숫자로 된 임의 개수의 전달인자를 받아서 그중 가장 큰 값을 반환한다.<br>(내장 함수 Math.max() 또한 이와 같이 동작한다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="comment">// 전달인자를 순회하며 가장 큰 값을 찾아 기억한다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 가장 큰 값을 반환</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> largest = max(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>);  <span class="comment">// 10000</span></span><br></pre></td></tr></table></figure></p>
<p>임의 개수의 전달인자를 받을 수 있는 함수를 보통 varadic 함수, variable arity 함수, varargs 함수 등으로 부른다.</p>
<p>varargs 함수라고 할지라도 전달인자 없이 호출되는 경우를 허용할 필요는 없다.<br>이름이 붙은 고정 개수의 전달ㅇ니자 뒤에 임의 개수의 전달인자를 받는 함수를 작성할 때에도, arguments[] 객체는 아주 유용하다.</p>
<p>arguments는 실제로는 배열이 아니라 <strong>Arguments</strong> 객체다.<br>각 Arguments 객체는 숫자 인덱스가 붙은 배열 원소와 length 프로퍼티를 가지고 있다.<br>하지만, 기술적으로 보면 배열은 아니다.<br>어쩌다가 숫자로 된 프로퍼티들을 가지게 된 객체라고 생각하는 편이 낫다.</p>
<p>Arguments 객체에는 별난 특징이 하나 있다.<br>비-엄격모드에서 만약 함수에 매개변수가 정의되어 있으면, Arguments 객체의 배열 원소는 각 매개변수의 별칭과 같다.<br>즉, Arguments 객체의 배열 원소와 매개변수의 이름은 동일한 값을 가리키는 다른 두 이름이다.<br>전달인자의 이름을 사용하여 인자 값을 변경하면 arguments[] 배열 원소의 값도 바뀐다.<br>그 반대로 arguments[] 배열 원소의 인자 값을 변경하면 전달인자 이름으로 얻을 수 있는 값도 바뀐다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 전달인자의 초기 값을 출력</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="literal">null</span>;    <span class="comment">// arguments 배열 요소를 변경하면 초기 값이 바뀜</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이것은 Arguments 객체가 평범한 배열이라면 볼 수 없는 특징이다.<br>만약 Arguments 객체가 평범한 배열이라면, 처음에 arguments[0]과 x는 같은 값을 가질 수 있지만,<br>하나를 변경하는 작업이 다른 하나에 영향을 미치지는 않을 것이다.</p>
<p>Arguments 객체의 이런 특별한 동작은 <em>ECMAScript 5</em>의 엄격 모드에서는 제거되었다.<br>뿐만 아니라 엄격 모드와 관련하여 다른 차이점도 있다.<br>일반 모드의 함수에서 arguments는 하나의 식별자일 뿐이지만 엄격 모드에서는 예약어나 마찬가지다.<br>엄격 모드에서 함수는 arguments를 매개변수 이름이나 지역 변수 이름으로 사용할 수 없다.<br>그리고 arguments에 어떤 값을 할당할 수도 없다.</p>
<h3 id="gt-callee와-caller-속성"><a href="#gt-callee와-caller-속성" class="headerlink" title="&gt; callee와 caller 속성"></a>&gt; callee와 caller 속성</h3><p>Arguments 객체는 배열 원소 외에도 callee와 caller 프로퍼티를 정의하고 있다.<br><em>ECMAScript 5</em>의 엄격 모드에서 callee와 caller 속성을 읽으려고 하거나 쓰려고 하면 TypeError가 발생한다.<br>하지만, 엄격 모드가 아닐 때 <em>ECMAScript</em> 표준은 callee 프로퍼티가 현재 실행되고 있는 함수를 참조한다고 정의하고 있다.<br>callee는 비표준이지만 많은 자바스크립트 구현체에서 보편적으로 구현된 프로퍼티며, 이 함수를 호출한 함수를 참조한다.<br>caller 프로퍼티는 호출 스텍에 접근할 수 있도록 해주고, callee 프로퍼티는 이름없는 함수를 재귀적으로 호출하는데 유용하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x<span class="number">-1</span>);   <span class="comment">// 다시 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="객체의-프로퍼티를-전달인자로-사용하기"><a href="#객체의-프로퍼티를-전달인자로-사용하기" class="headerlink" title="- 객체의 프로퍼티를 전달인자로 사용하기"></a>- 객체의 프로퍼티를 전달인자로 사용하기</h2><p>어떤 함수에 세 개 이상의 매개변수가 있다면, 이 함수를 호출하는 프로그래머가 인자의 올바른 순서를 기억하기가 어려워진다.<br>프로그래머가 매번 함수를 사용할 때마다 문서를 참조해야 하는 문제에서 벗어나려면, 전달인자를 순서에 상관없이 이름/값의 쌍으로 함수에 전달하는 편이 효과적일 수 있다.<br>이런 방식으로 정의하고, 함수의 사용자에게 함수에서 요구하는 이름/값 쌍을 가진 객체를 함수의 인자로 넘기도록 하면 된다.<br>다음 코드는 이러한 방식을 구현한 예제이고, 또한 생략된 전달인자에 대해 기본 값을 지정하고 있음을 보여준다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 from에서 배열 to로 length 만큼의 요소를 복사한다</span></span><br><span class="line"><span class="comment">// from 배열의 from_start 요소로부터 복사를 시작하고</span></span><br><span class="line"><span class="comment">// to 배열의 to_start 위치부터 복사한 값을 써넣는다</span></span><br><span class="line"><span class="comment">// 여기서 올바른 전달인자의 순서를 기억하기란 어려운 일이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayCopy</span>(<span class="params"><span class="regexp">/* array */</span> from, <span class="regexp">/* index */</span> from_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="regexp">/* array */</span> to, <span class="regexp">/* index */</span> to_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="regexp">/* integer */</span> length</span>) </span>&#123;</span><br><span class="line">                       <span class="comment">// 배열을 복사하는 코드가 위치</span></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 버전은 조금 덜 효율적이지만 전달인자의 순서를 기억할 필요가 없다.</span></span><br><span class="line"><span class="comment">// 그리고 from_start와 to_start는 기본 값은 0이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easyCopy</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arrayCopy 호출</span></span><br><span class="line">    arrayCopy(args.from,</span><br><span class="line">              args.from_start || <span class="number">0</span>,</span><br><span class="line">              args.to_start || <span class="number">0</span>,</span><br><span class="line">              args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a에서 b로 배열을 복사할 것이다</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], b = [];</span><br><span class="line"><span class="comment">// easyCopy 호출</span></span><br><span class="line">easyCopy(&#123;<span class="attr">from</span>: a, <span class="attr">to</span>: b, <span class="attr">length</span>: <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="전달인자-형식"><a href="#전달인자-형식" class="headerlink" title="- 전달인자 형식"></a>- 전달인자 형식</h2><p>자바스크립트 함수의 매개변수에는 정의된 형식도 없고, 함수에 전달한 값에 대해서 자료형 검사도 하지 않는다.<br>함수 인자에 해당 인자를 잘 설명하는 이름을 선택하거나 또한 바로 앞의 arrayCopy() 함수처럼 주석으로 인자의 자료형을 명시하면 코드를 문서화하는 데 도움이 된다.<br>생략 가능한 전달인자에 대해서는 <strong>‘optional’</strong>이라는 단어를 주석에 포함시키자.<br>그리고 함수가 임의 개수의 인자를 받는다면 다음과 같이 줄임표 부호를 사용하면 좋다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="regexp">/* 숫자 값... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 코드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>자바스크립트는 필요에 따라 자유롭게 자료형 변환을 수행한다.<br>만약 문자열 인자를 요구하는 함수를 문자열이 아닌 다른 자료형의 인자로 넘겨 호출하면, 그 인자의 값은 해당 함수가 인자를 문자열로 사용하려 할 떄 문자열로 변환될 것이다.<br>모든 원시 형식은 문자열로 변환될 수 있고, 또 모든 객체에는 toString() 메서드가 있으므로 문자열로 변환되는 경우에는 어떤 에러도 발생하지 않는다.</p>
<p>하지만, 항상 이런 것은 아니다.<br>앞에서 다룬 arrayCopy() 함수를 다시 보면,<br>이 함수는 첫 번째 인자로 배열을 요구한다.<br>이 함수를 적절히 구현했다면, 만약 첫 번째 인자가 배열 또는 유사배열 객체가 아닐 떄 호출은 실패할 것이다.<br>한두 번만 사용하고 버릴 함수가 아니라면, 인자 자료형을 검사하는 코드를 추가할 가치가 있는 것이다.<br>함수에 적절치 않은 값이 전달되면 함수를 실행하고 나중에 불명확한 메시지를 발생시키며 실패하는 것보단 전달되자 마자 예측할 수 있는 형태로 즉시 실패하는 편이 낫다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o가 배열과 유사한 객체인지 판별</span></span><br><span class="line"><span class="comment">// 문자열과 함수는 length 프로퍼티를 갖고 있지만, 이를 typeof를 통해서 걸러낼 수 있다</span></span><br><span class="line"><span class="comment">// 클라이언트 측 자바스크립트 DOM의 text node가 length 프로퍼티를 갖고 있고,</span></span><br><span class="line"><span class="comment">// 이를 o.nodeType != 3으로 걸러낼 수 있다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o는 null이나 undefined 등등이 아님</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp;                <span class="comment">// o는 객체</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                   <span class="comment">// o의 길이는 유한하다</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o의 길이는 0 이상이다</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length는 정수다</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>) &#123;                <span class="comment">// o.length &lt; 2^32가 성립</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// o는 유사배열이다</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                       <span class="comment">// o는 배열과 비슷하지 않다</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열(혹은 유사배열 객체) 요소의 전체 합을 반환</span></span><br><span class="line"><span class="comment">// 모든 요소는 숫자여야 하고 null과 undefined는 무시한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isArrayLike(a)) &#123;</span><br><span class="line">        <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 모든 배열의 요소를 순회</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> element = a[i];</span><br><span class="line">            <span class="comment">// 만약 요소가 null이나 undefined면 다음으로 건너 뜀</span></span><br><span class="line">            <span class="keyword">if</span> (element === <span class="literal">null</span> || element === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 유한수라면 total에 요소를 더함</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isFinite</span>(element)) &#123;</span><br><span class="line">                total += element;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"sum(): 요소는 반드시 유한수여야 합니다."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이 sum() 함수는 받아들이는 인자에 대해 꽤 엄격하며, 적절하지 않은 값이 전달되면 적절한 정볼르 담은 에러를 발생(throw)시킨다.<br>하지만 이 함수는 실제 배열 외에 유사배열 객체와도 호환되며, null과 undefined 배열 요소는 무시하는 유연성도 갖췄다.</p>
<p>자바스크립트는 매우 유연하며 자료형을 느슨하게 처리하는 언어이기에, 때로는 인자 개수와 자료형에 유연한 함수를 작성하는 것이 바람직하다.<br>아래 flexiSum() 함수는 이런 유연한 접근 방식을 따른다.<br>이를테면 이 함수는 임의 개수의 인자를 받지만, 배열 형식의 인자는 재귀적으로 처리한다.<br>이런 방식으로 인해 이 함수는 varargs 함수로 사용될 수도 있고 배열 인자를 주어 호출할 수도 있다.<br>게다가 이 함수는 에러를 던지기 전에 숫자가 아닌 값들을 최대한 숫자로 변환하려고 시도한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flexiSum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> element = <span class="built_in">arguments</span>[i]; <span class="comment">// 전달된 인자를 뺴옴</span></span><br><span class="line">        <span class="keyword">var</span> n;  <span class="comment">// 인자의 숫자 변환 결과를 저장할 변수</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// null과 undefined 인자는 무시</span></span><br><span class="line">        <span class="keyword">if</span> (element === <span class="literal">null</span> || element === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 만약 인자가 배열이라면</span></span><br><span class="line">        <span class="keyword">if</span> (isArray(element)) &#123;</span><br><span class="line">            n = flexiSum.apply(<span class="keyword">this</span>, element);  <span class="comment">// 재귀적 방식을 통해 합계를 계산</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">"function"</span>) &#123; <span class="comment">// 인자가 함수라면</span></span><br><span class="line">            n = <span class="built_in">Number</span>(element());  <span class="comment">// 인자(함수)를 호출하고 숫자로 변환</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 그도 아니라면 숫자로 변환</span></span><br><span class="line">            n = <span class="built_in">Number</span>(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 숫자로 변환할 수 없다면</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"flexiSum(): can't convert "</span> + element + <span class="string">" to number"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        total += n; <span class="comment">// 정상적인 숫자라면 total에 n을 더함</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="값으로서의-함수"><a href="#값으로서의-함수" class="headerlink" title="값으로서의 함수"></a>값으로서의 함수</h1><p>함수의 가장 중요한 특징은 정의될 수 있고 또 호출될 수 있다는 점이다.<br>함수 정의와 호출은 자바스크립트뿐만 아니라 다른 대부분 프로그래밍 언어의 문법적 특징이다.</p>
<p>하지만, 자바스크립트에서 함수는 문법일 뿐만 아니라 <strong>값</strong>이기도 한데,<br>이는 함수가 <strong>변수에 할당</strong>될 수 있고,<br><strong>객체의 프로퍼티나 배열 원소로 저장</strong>될 수도 있으며,<br>다른 <strong>함수의 인자로 전달</strong>될 수도 있고, 기타 여러 방식으로 사용될 수 있음을 뜻한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 정의는 새 함수 객체를 생성하고 이를 변수 square에 할당한다.<br>함수의 이름은 사실 실체가 없는 개념이다.<br>함수 객체를 참조하는 변수의 이름일 뿐이기 때문이다.</p>
<p><strong>함수는 다른 변수에 할당</strong>될 수도 있고, 그렇게 하더라도 여전히 똑같이 작동한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = square; <span class="comment">// s는 square와 같은 함수를 참조한다</span></span><br><span class="line">square(<span class="number">4</span>);      <span class="comment">// 16</span></span><br><span class="line">s(<span class="number">4</span>);           <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>또한 함수는 변수 외에도 <strong>객체 프로퍼티에 할당</strong>될 수도 있는데, 이를 <strong>메서드</strong>라고 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    square: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.square(<span class="number">4</span>);    <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>함수를 배열 요소에 할당한다면 이름은 필요없다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * z;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]); <span class="comment">// 400</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>다음은 함수가 값으로 사용될 때 할 수 있는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subtract</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 함수 중 하나를 인자로 받아 두 개의 피연산자와 같이 호출하는 함수를 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operate</span>(<span class="params">operator, operand1, operand2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator(operand1, operand2);    <span class="comment">// 인자로 받은 함수에 두 피연산자를 파라메터로 전달</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2+3) + (4*5)</span></span><br><span class="line">operate(add, operate(add, <span class="number">2</span>, <span class="number">3</span>), operate(multiply, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수를 메서드로 생성</span></span><br><span class="line"><span class="keyword">var</span> operators = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;,</span><br><span class="line">    multiply: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;,</span><br><span class="line">    divide: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;,</span><br><span class="line">    pow: <span class="built_in">Math</span>.pow   <span class="comment">// 자바스크립트에서 미리 정의된 메서드도 사용 가능</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자의 이름을 인자로 받아, operators객체 안에서 메서드를 찾고, 같이 인자로 전달된 두 개의 피연산자를 파라메터로 전달</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operate2</span>(<span class="params">operationName, operand1, operand2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> operators[operationName] === <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> operators[operationName](operand1, operand2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"알 수 없는 연산자"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "hello" + " " + "world"</span></span><br><span class="line">operate2(<span class="string">"add"</span>, <span class="string">"hello"</span>, operate2(<span class="string">"add"</span>, <span class="string">" "</span>, <span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 미리 정의된 Math.pow() 메서드를 사용</span></span><br><span class="line">operate2(<span class="string">"pow"</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p><br><br>값으로서의 함수에 대한 다른 예로, Array.sort() 메서드를 들 수 있다.<br>이 메서드는 배열의 요소를 정렬한다.<br>사용할 수 있는 정렬 기준은 아주 많기 때문에, sort() 메서드는 정렬을 어떻게 수행할지 알려주는 함수를 선택적 인자로 받는다.<br>선택적 인자로 받는 함수가 하는 일은 간단하다.<br>전달된 두 값 중에서 어떤 값이 정렬된 배열에서 먼저 나와야 하는지를 명시하는 값을 반환한다.<br>이러한 함수 인자 때문에 Array.sort()는 완전히 일반화(generic)되고 한없이 유연해진다.<br>어떤 형식의 데이터라도 원하는 모든 순서로 정렬할 수 있다.<br><br></p>
<h2 id="자신만의-함수-프로퍼티-정의하기"><a href="#자신만의-함수-프로퍼티-정의하기" class="headerlink" title="- 자신만의 함수 프로퍼티 정의하기"></a>- 자신만의 함수 프로퍼티 정의하기</h2><p>자바스크립트에서 함수는 원시 값이 아니지만 특별한 종류의 객체이고 이는 함수가 프로퍼티를 가질 수 있음을 의미한다.<br>함수가 여러번 호출되어도 그 값이 유지되어야 하는 ‘정적’변수가 필요할 때는,<br>전역 변수를 선언해서 네임스페이스를 난잡하게 하기보다 함수의 프로퍼티를 사용하는 것이 편리한 경우가 많다.</p>
<p>예를 들어 호출될 때마다 유일한 정수 값을 반환하는 함수를 작성한다고 가정해보자.<br>이 함수는 같은 값을 두 번 반환해서는 안된다.<br>이런 정보를 전역 변수에 저장할 수도 있지만 그럴경우 부적합하다. 왜냐하면 그 정보는 오직 해당 함수만 사용하기 때문이다.<br>그러므로 이러한 정보는 함수 객체의 프로퍼티에 저장하는 편이 더 낫다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체의 counter 프로퍼티를 초기화한다</span></span><br><span class="line"><span class="comment">// uniqueInteger 함수 정의는 끌어올려져 해석되기 때문에(hoisted)</span></span><br><span class="line"><span class="comment">// 실제 uniqueInteger 함수 정의 문 앞보다 먼저 사용할 수 있다.</span></span><br><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 함수는 호출될 때마다 매번 다른 정수를 반환</span></span><br><span class="line"><span class="comment">// 다음 반환 값을 기억하기 위해 자신의 프로퍼티를 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInteger.counter++; <span class="comment">// counter 프로퍼티를 반환하고 증가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>다음은 계산한 결과를 저장하도록 자신의 프로퍼티를 사용하는 factorial() 함수다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 유한한 양의 정수만 받음</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n === <span class="built_in">Math</span>.round(n)) &#123;</span><br><span class="line">        <span class="comment">// 만약 저장 해둔 결과가 없다면</span></span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123;</span><br><span class="line">            factorial[n] = n * factorial(n<span class="number">-1</span>);  <span class="comment">// 팩토리얼을 계산하고 계산 값을 저장</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];    <span class="comment">// 계산 값을 반환</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>; <span class="comment">// 잘못된 입력 값이 들어오면 NaN을 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 저장을 기본 경우(1)에 대한 값으로 초기화</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="네임스페이스로서의-함수"><a href="#네임스페이스로서의-함수" class="headerlink" title="네임스페이스로서의 함수"></a>네임스페이스로서의 함수</h1><p>자바스크립트는 함수 단위의 유효범위를 갖는다.<br>함수 내부에서 정의된 변수는 해당 함수 내부(중첩 함수를 포함한)에서는 접근할 수 있지만,<br>그 함수 바깥에는 존재할 수 없다.<br>함수 밖에서 정의된 변수는 전역 변수이고 자바스크립트 프로그램 전체에서 접근할 수 있다.</p>
<p>자바스크립트는 단일 코드 블록 내에서만 유효한 변수를 정의하는 방법을 제공하지 않기에,<br>간단한 임시 네임스페이스처럼 작동하는 함수를 정의하는 기법은 전역 네임스페이스를 어지럽히지 않고도 변수를 정의할 수 있어서 유용하게 사용되는 방법이다.</p>
<p>예를 들어 어떤 자바스크립트 모듈이 있고, 이 모듈을 다수의 다른 자바스크립트 프로그램(클라이언트 측 자바스크립트일 경우에는 다수의 다른 웹 페이지)에서 사용한다고 가정하자.<br>이 코드는 계산의 중간 결과 값을 저장하는 변수가 있다.<br>문제는 이 모듈은 여러 프로그램의 변수와 충돌을 일으킬 수 있다는 것이다.<br>물론 해결책은 모듈의 코드를 함수내에 두고 그 함수를 호출하는 것이다.<br>이런 방식으로 변수들을 전역 변수로 취급하는 대신 그 함수의 지역 변수로 다룰수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 모듈 코드</span></span><br><span class="line">    <span class="comment">// 모듈에서 사용하는 변수 (지역변수)</span></span><br><span class="line">&#125;</span><br><span class="line">myModule(); <span class="comment">// 함수를 호춣해야 한다</span></span><br></pre></td></tr></table></figure></p>
<p>이 코드는 이름이 ‘myModule’인 단 하나의 전역 변수만 정의한다.<br>하나의 프로퍼티(여기서는 함수)를 정의하는 것도 과하다면, <strong>익명 함수</strong>를 정의하고 호출하는 단일 표현식을 이용하는 방법도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 이름 없는 표현식 (익명 함수)</span></span><br><span class="line">    <span class="comment">// 모듈 코드</span></span><br><span class="line">&#125;());   <span class="comment">// 함수 정의를 하고 바로 호출</span></span><br></pre></td></tr></table></figure></p>
<p>이렇게 단일 표현식으로 함수를 정의하고 호출하는 방식은 관용적으로 자주 사옹되는 기법이다.<br>앞 코드에서 중괄호 부분을 보면, 함수 앞의 시작 괄호(<code>(</code>)는 반드시 필요하다.<br>만약 시작 괄호가 없다면 자바스크립트 인터프리터는 <code>function</code> 키워드를 함수 선언문으로 해석하기 때문이다.<br>괄호가 있으면 인터프리터는 이것을 표현식 형태의 함수 선언으로 올바르게 인식한다.<br>괄호가 꼭 필요하지 않은 상황에서도, 정의하자 마자 호출할 함수를 괄호로 둘러싸는 것은 관용적인 방식이다.</p>
<p>다음은 이런 네임스페이스 기법을 사용하여 extend() 함수를 반환하는 익명 함수를 정의한다.<br>익명 함수의 코드는 IE의 잘 알려진 버그가 있는지 검사하고, 만약 버그가 있다면 패치된 함수를 반환한다.<br>또한 이 익명 함수의 네임스페이스는 프로퍼티 이름 배열을 내부로 감추는 구실도 하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extend 함수</span></span><br><span class="line"><span class="comment">// extend 함수는 두 번째 인자와 그 다음에 오는 인자들의 프로퍼티를 첫 번째 인자로 복사한다</span></span><br><span class="line"><span class="comment">// 여기서 IE의 버그에 대응하는데, 만약 객체 o의 프로토타입에 열거할 수 없는 프로퍼티가 있고</span></span><br><span class="line"><span class="comment">// 객체 o에는 그 프로퍼티와 이름이 같은 프로퍼티가 열거 가능하다면,</span></span><br><span class="line"><span class="comment">// IE의 여러 버전에서 for/in 루프는 객체 o의 열거 가능한 프로퍼티를 제대로 열거하지 못한다</span></span><br><span class="line"><span class="comment">// 즉, toString()과 같은 프로토타입에서 상속받은 프로퍼티는 명시적으로 검사하지 않는 한 제대로 처리될 수 없다</span></span><br><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 검사해야 하는 특별한 프로퍼티의 목록</span></span><br><span class="line">    <span class="keyword">var</span> protoprops = [<span class="string">"toString"</span>, <span class="string">"valueOf"</span>, <span class="string">"constructor"</span>, <span class="string">"hasOwnProperty"</span>,</span><br><span class="line">                      <span class="string">"isPrototypeOf"</span>, <span class="string">"propertyIsEnumerable"</span>, <span class="string">"toLocaleString"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 여기에 이르면 for/in 루프가 제대로 작동한 것이고</span></span><br><span class="line">    <span class="comment">// extend() 함수의 단순한 버젼을 반환한다</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> &#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = i; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="comment">// 열거 가능한 프로퍼티를 복사</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 여기에 이르면, for/in 루프는 테스트 객체의 toString 프로퍼티를 제대로 열거하지 못했다는 뜻이다</span></span><br><span class="line">    <span class="comment">// 따라서 Object.prototype의 열거할 수 없는 프로퍼티를 명시적으로 테스트하는 extend() 함수를 반환한다</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = i; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="comment">// 열거 가능한 프로퍼티를 복사</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 그리고 이제 특별한 프로퍼티를 검사</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; protoprops.length; j++) &#123;</span><br><span class="line">                <span class="keyword">var</span> prop = protoprops[j];</span><br><span class="line">                <span class="keyword">if</span>(source.hasOwnProperty(prop)) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p>대다수의 현대 프로그래밍 언어와 마찬가지로 자바스크립트 또한 어휘의 <strong>유효범위(lexical scoping)</strong>를 사용한다.<br>이는 함수를 호출하는 시점에서의 변수 유효범위가 아니라, 함수가 정의된 시점의 변수 유효범위를 사용하여 함수가 실행된다는 뜻이다.<br>이러한 어휘적 유효범위를 구현하기 위해, 자바스크립트 함수 객체는 내부 상태에 함수 자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다.<br>함수 객체와, 함수의 변수가 해석되는 유효범위(변수 바인딩의 집합)를 아울러 <strong>클로저(closure)</strong>라고 한다.</p>
<p>기술적으로 모든 자바스크립트 함수는 클로저인데, 함수는 객체이고 함수 자신과 관련된 유효범위 체인을 가지고 있기 때문이다.<br>함수 대부분은 함수가 정의되었을 때의 유효범위 체인을 사용하여 호출되고, 클로저가 개입되었는지의 여부는 중요하지 않다.<br>클로저는 정의된 유효범위와 다른 유효범위 체인에서 사용될 때 더욱 흥미롭다.<br>가장 일반적인 경우는 어떤 함수가 그 함수 내부에서 정의한 중첩 함수를 반환하는 것이다.<br>중첩 함수 클로저와 관련한 여러 강력한 프로그래밍 기법들이 있고, 다른 언어에 비해 자바스크립트에서는 이러한 기법이 일반적으로 사용된다.</p>
<p>클로저를 이해하는 첫 걸음은 중첩 함수의 어휘적 유효범위 규칙을 다시 살펴보는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 지역 변수</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="comment">// 유효범위에 있는 값을 반환</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkScope();   <span class="comment">// "local scope"</span></span><br></pre></td></tr></table></figure></p>
<p>위 checkScope() 함수는 지역 변수를 선언한 다음, 그 지역 변수를 반환하는 함수를 정의하고 호출한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 지역 변수</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="comment">// 유효범위에 있는 값을 반환</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;   <span class="comment">// "local scope"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkScope()();   <span class="comment">// "local scope"</span></span><br></pre></td></tr></table></figure>
<p>한 쌍의 괄호가 checkScope() 안에서 밖으로 이동했다.<br>이제 checkScope()는 중첩 함수 객체 그 자체를 반환하는 대신, 중첩 함수 객체 그 자체를 반환한다.<br>중첩 함수가 정의된 위치의 외부에서 해당 중첩 함수를 호출했을 때(코드에서 마지막 줄에 있는 두 번째 괄호), 어떤 값을 반환하겠는가?</p>
<p>자바스크립트 함수는 함수가 정의되었을 떄의 유효범위 체인을 사용하여 실행된다.<br>중첩 함수가 f()가 정의된 유효범위 체인에서 변수 scope는 “local scope”로 바인드되어 있다.<br>f가 어디서 호출되든 상관없이, f가 실행될 때 이 바인딩은 항상 유효하다.<br>따라서 마지막 코드 checkScope()();는 “local scope”를 반환한다.<br>간단히 말해서, 이것이 클로저의 강력한 특성이다.<br><strong>클로저는 자신을 정의한 바깥쪽 함수에 바인딩된 지역 변수(그리고 전달인자)를 포착한다.</strong></p>
<blockquote>
<p><strong>클로저 구현</strong><br>어휘적 유효범위 규칙에서 함수는, 함수가 정의되었을 때의 유효범위 체인을 사용하여 실행되며,<br>이러한 유효범위 체인 규칙을 간단히 받아들일 수 있다면 클로저는 이해하기 쉽다.<br>보통 바깥쪽 함수에서 정의된 지역 변수는 바깥쪽 함수의 실행이 종료되면 없어질 텐데, 어떻게 더 이상 존재하지 않는 유효범위 체인을 사용하여 중첩 함수가 실행될 수 있을지 의문을 갖는다.</p>
<p>자바스크립트 함수가 호출될 때마다 해당 호출과 관련한 지역 변수를 보관하는 객체가 생성되고,<br>이 객체는 함수의 유효범위 체인에 추가된다.<br>함수가 반환되면, 객체와 바인딩된 변수는 유효범위 체인에서 제거된다.</p>
<p>만약 중첩 함수를 정의하지 않았다면, 객체와 바인딩된 변수는 더 남아있지 않게되고 가비지 컬렉션 대상이된다.<br>만약 중첩 함수가 정의되어 있다면, 각 중첩 함수에는 유효범위 체인에 대한 참조가 있고, 이 유효범위 체인은 객체와 바인딩된 변수를 참조하고 있다.<br>만약 중첩 함수 객체가 바깥쪽 함수 내부에만 사용된다면, 중첩 함수는 그들이 참조하는 변수들과 함께 가비지 컬렉션 대상이된다.</p>
<p>하지만 만약 어떤 함수가 중첩 함수를 정의하고 그 함수를 반환하거나 어딘가의 프로퍼티로 저장한다면, 함수 외부에 중첩 함수에 대한 참조가 생기게 된다.<br>이 경우, 중첩 함수는 가비지 컬렉션되지 않을 것이고 중첩 함수가 참조하는 변수 또한 가비지 컬렉션되지 않을 것이다.</p>
</blockquote>
<p><br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이 함수는 호출될 때마다 매번 다른 정수를 반환</span></span><br><span class="line"><span class="comment">// 다음 반환 값을 기억하기 위해 자신의 프로퍼티를 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInteger.counter++; <span class="comment">// counter 프로퍼티를 반환하고 증가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>uniqueInteger() 함수는 다음에 반환할 값을 유지하기 위해 함수 자신의 프로퍼티를 사용한다.<br>이런 방식의 한 가지 결점은, 버그가 있는 코드나 악성 코드가 counter를 초기화하거나 정수가 아닌 값으로 프로퍼티를 설정할 수 있고,<br>그 결과로 uniqueInteger() 함수가 ‘유일한(unique)’ 또는 ‘정수(Integer)’라는 규약을 위반하게 할 수 있다는 것이다.</p>
<p>클로저는 함수의 지역 변수를 포착하고, 이 변수들을 내부 상태로 사용할 수 있다.<br>uniqueInteger() 함수가 클로저를 사용하도록 코드를 작성하자.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 함수를 정의하고 바로 호출</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;    <span class="comment">// 아래 함수의 내부 상태</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>이 코드는 함수를 변수 uniqueInteger에 할당하는 것처럼 보인다.<br>사실, 함수를 정의하고 호출하는 것이며, 함수의 반환 결과가 uniqueInteger에 할당된다.</p>
<p>함수의 몸체를 보면, 함수의 반환값은 또 다른 함수이다.<br>중첩 함수는 유효범위에 있는 변수에 접근하고, 바깥쪽 함수에 정의된 counter 변수를 사용할 수 있다.<br>바깥쪽 함수의 실행이 끝나면, 어떤 코드도 counter 변수를 볼 수 없다.<br>오직 안쪽 함수만 단독으로 counter 변수에 접근할 수 있을 뿐이다.</p>
<p>counter와 같은 내부 변수는 여러 클로저가 공유할 수 있다.<br>즉, <strong>같은 함수 안에 정의된 중첩 함수들은 같은 유효범위 체인을 공유</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 개의 counter 생성</span></span><br><span class="line"><span class="keyword">var</span> c = counter();</span><br><span class="line"><span class="keyword">var</span> d = counter();</span><br><span class="line"></span><br><span class="line">c.count();  <span class="comment">// 0</span></span><br><span class="line">d.count();  <span class="comment">// 0</span></span><br><span class="line">c.reset();  <span class="comment">// c안의 중첩 함수인 count() 메서드와 reset() 메서드는 상태를 공유한다</span></span><br><span class="line">c.count();  <span class="comment">// 0 : c는 reset() 메서드에 의해 0으로 초기화 되었다</span></span><br><span class="line">d.count();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>counter() 함수는 ‘카운터’ 객체를 반환한다.<br>이 객체는 두 메서드를 가지고 있는데, count() 메서드는 그 다음에 올 정수를 반환하고,<br>reset() 메서드는 내부 상태(n)을 재설정한다.<br>이 두 메서드는 ‘private variable’, 즉 내부 변수 n을 공유한다.<br>counter()를 호출할 때마다 새로운 유효범위 체인과 새로운 내부 변수가 생성된다.<br>따라서 counter()를 두번 호출하면, 서로 다른 내부 변수를 가진 두 개의 counter 객체를 얻는다.<br>한 카운터 객체(c)에 count()나 reset()을 호출하는 것은, 다른 카운터 객체(d)에는 아무 영향을 주지 않는다.</p>
<p>클로저 기법과 <code>getter/setter</code> 프로퍼티를 결합할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// getter</span></span><br><span class="line">        get count() &#123;</span><br><span class="line">            <span class="comment">// n 변수를 반환하고 증가</span></span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// setter</span></span><br><span class="line">        set count(m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n) &#123;</span><br><span class="line">                <span class="comment">// m값으로 n변수에 할당</span></span><br><span class="line">                n = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"count는 오직 더 큰 값만 설정 가능"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count;        <span class="comment">// 1000</span></span><br><span class="line">c.count;        <span class="comment">// 1001</span></span><br><span class="line">c.count = <span class="number">2000</span>;</span><br><span class="line">c.count;        <span class="comment">// 2000</span></span><br><span class="line">c.count = <span class="number">2000</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p>
<p>이 counter() 함수는 지역 변수를 정의하지 않지만, 프로퍼티 접근 메서드들이 공유하는 내부 상태를 보관하기 위해 매개변수 n을 사용한다.<br>이로써 counter()를 호출하는 쪽에서 내부 변수의 초기 값을 지정할 수 있다.</p>
<p>위에서 살펴본 클로저 기법을 이용하여 내부 상태를 공유하는 기법을 일반화 해보자.<br>addPrivateProperty() 함수는 하나의 내부 변수와 그 변수를 얻고 설정하는 두 중첩 함수를 정의한다.<br>그리고 두 중첩 함수를 특정 객체의 메서드로 추가한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이 함수는 프로퍼티 접근 메서드를 객체 o의 프로퍼티에 특정 이름으로 추가한다</span></span><br><span class="line"><span class="comment">// 메서드 이름은 get&lt;name&gt;과 set&lt;name&gt; 이 된다</span></span><br><span class="line"><span class="comment">// 만약 단정(predicate) 함수가 제공되면, setter 메서드는 전달된 인자를 저장하기 전에</span></span><br><span class="line"><span class="comment">// 인자 유효성을 테스트 하기위해 단정 함수를 사용한다</span></span><br><span class="line"><span class="comment">// 만약 단정 함수가 false를 반환하면 setter 메서드는 예외를 발생시킨다</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 주의할 것은, getter/setter 메서드가 제어하고 있는 프로퍼티 값이</span></span><br><span class="line"><span class="comment">// 객체 o에 저장되지 않는 것이다. 대신, 그 값은 오직 이함수의 지역 변수(value)로만 저장된다</span></span><br><span class="line"><span class="comment">// 또한, getter/setter 메서드는 이 함수 내부에 지역적으로 정의되기 때문에 이 함수의 지역 변수에 접근할 수 있다.</span></span><br><span class="line"><span class="comment">// 즉, value 변수는 두 접근 메서드 전용이고, setter 메서드를 통하지 않고서는 설정되거나 수정할 수 없다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;  <span class="comment">// 프로퍼티 값</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// name으로 getter 메서드 생성</span></span><br><span class="line">    o[<span class="string">"get"</span>+name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;   <span class="comment">// getter 메서드는 value를 반환</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name으로 setter 메서드 생성</span></span><br><span class="line">    o[<span class="string">"set"</span>+name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 단정함수는 있으나 false를 반환할때</span></span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"set"</span>+name+<span class="string">":유효하지 않은 값 "</span> + v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다음 코드는 addPrivateProperty() 메서드를 사용하는 방법을 보여준다</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 접근 메서드 getName()과 setName()을 추가</span></span><br><span class="line"><span class="comment">// 문자열 값만 설정가능하도록</span></span><br><span class="line">addPrivateProperty(o, <span class="string">"Name"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">"Frank"</span>); <span class="comment">// 프로퍼티 값을 설정</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName());   <span class="comment">// 설정한 프로퍼티 값을 얻음</span></span><br><span class="line">o.setName(<span class="number">0</span>);   <span class="comment">// 문자열이 아닌 다른 자료형을 집어넣음</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constFunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상수 함수에 대한 배열을 생성</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = constFunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs[<span class="number">5</span>](); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>이 코드는 클로저들이 서로 다른 변수의 값을 가지고 있는 상태이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0~9 값을 반환하는 함수들의 배열을 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constFuncs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constFuncs();</span><br><span class="line">funcs[<span class="number">5</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>이 코드는 열 개의 클로저를 생성하고, 생성한 클로저들을 배열에 저장한다.<br>모든 클로저는 같은 함수 호출 내에서 정의되고, 따라서 클로저들은 변수 i에 대한 접근을 공유한다.<br>constFuncs() 실행이 끝나면, 변수 i의 값은 10이고, 열 개의 클로저 모두 이 값을 공유한다.<br>클로저와 연관된 유효범위 체인이 ‘살아있다’는 사실을 기억해야 한다.<br>중첩 함수는 유효범위에 대한 내부 사본이나 변수 바인딩의 스냅샷 따위는 만들지 않는다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/circleGiven" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/in/wonjune/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-04-19T15:29:21.604Z"><meta itemprop="articleBody" content="함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.함수 정의에는 매개변수(parameter), 또는 형식인자라고 불리는 식별자 목록이 포함될 수 있는데, 이 매개변수는 함수 몸체 내에서 지역 변수처럼 취급된다.함수 호출시 에는 함수의 매개변수에게 값, 즉 실인자(arguments)들을..."><meta itemprop="url" content="http://yoursite.com/2018/03/27/javascript-function/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/03/27/javascript-function/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/03/31/javascript-dom/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 문서 객체 모델 (DOM)</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/16/javascript-object/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 객체</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/09/null-undefined/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript&gt;&gt; null vs undefined</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/07/28/book-passionate-part3/">프로그래머, 실행</a></li><li class="recent-posts__item"><a href="/2018/07/21/book-passionate-part2/">프로그래머, 자신에게 투자하라</a></li><li class="recent-posts__item"><a href="/2018/07/19/book-passionate-part1/">프로그래머, 당신의 시장을 선택하라</a></li><li class="recent-posts__item"><a href="/2018/06/18/jhipster-start/">JHipster | JHipster 시작하기</a></li><li class="recent-posts__item"><a href="/2018/04/13/spring-ioc/">Spring | 컨테이너와 결합도</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ajax/">Ajax</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/The-Passionate-Programmer/">The Passionate Programmer</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JHipster/">JHipster</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Basic/">Basic</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program/">Program</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Program/SICP/">SICP</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Speech/">Speech</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Basic/">Basic</a><span class="category-list-count">2</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>