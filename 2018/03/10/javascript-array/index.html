<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 배열 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/03/10/javascript-array/"/>
<meta name="description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 배열">
<meta property="og:url" content="http://yoursite.com/2018/03/10/javascript-array/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-03-24T08:03:55.846Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 배열">
<meta name="twitter:description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-03-10 15:20:26"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 배열</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-03-10T06:20:26.000Z" itemprop="datePublished">2018-03-10 15:20:26</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Javascript/">Javascript</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Javascript/Basic/">Basic</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p>배열은 정렬된 값의 <strong>집합</strong>이다.<br>배열 안의 각 값은 <strong>원소(element)</strong>라고 한다.<br>각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 <strong>인덱스(index)</strong>라고 한다.</p>
<p>자바스크립트의 배열은 타입이 고정되어 있지 않다.<br>즉, 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다.<br>배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도 있다.</p>
<p>자바스크립트 배열은 32비트 인덱스를 사용한다.<br>첫 번째 원소의 인덱스는 0이며, 가장 큰 인덱스로는 4294967294(2^32 -2)까지 사용할 수 있다.<br>즉, 배열은 4,294,967,295개의 원소를 가질 수 있다.</p>
<p>자바스크립트 배열은 <strong>동적</strong>이다.<br>배열의 크기가 필요에 따라 커질 수도 있고, 작아질 수도 있다.<br>배열을 생성하거나, 크기가 변경되어 다시 할당을 할 때도 배열 크기를 선언할 필요가 없다.</p>
<p>자바스크립트 배열은 <strong>밀집도가 높지 않다(sparse)</strong>.<br>각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈 자리가 있어도 된다.</p>
<p>자바스크립트 배열에는 <strong>length</strong> 프로퍼티가 존재한다.<br>빈자리가 전혀 없는 배열의 경우 length 프로퍼티의 값은 배열의 크기와 같지만,<br><strong>희소배열(sparse array)</strong>의 경우는 실제 원소의 크기보다 크다.</p>
<p>자바스크립트 배열은 자바스크립트 <strong>객체의 특별한 형태</strong>이고,<br>배열의 인덱스는 프로퍼티 이름인데, 하필 정수인 것이라고 보면 된다.</p>
<p>일반적으로 배열은 객체 프로퍼티를 통해 원소에 접근하는 것보다,<br>정수 첨자를 통해 원소에 접근하는 것이 훨씬 빠르도록 최적화되어 있다.</p>
<p>배열은 <strong>Array.prototype</strong>의 프로퍼티들을 상속받는다.<br>Array.prototype에는 배열을 다루는 여러 메서드가 정의되어 있다.<br>대부분의 메서드는 <strong>제너릭(generic)</strong> 형태이고,<br>이 말은 배열뿐 아니라 <strong>‘유사 배열 객체(array-like object)’</strong>에서도 동일하게 동작한다는 의미이다.<br><br><br><br></p>
<h1 id="배열-만들기"><a href="#배열-만들기" class="headerlink" title="배열 만들기"></a>배열 만들기</h1><p>배열을 만드는 가장 쉬운 방법은 배열 리터럴(<code>[]</code>)을 사용하는 것이다.<br>배열 리터럴은 배열의 원소를 쉼표(<code>,</code>)로 구분해 나열한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];                 <span class="comment">// 원소가 없는 배열</span></span><br><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>];      <span class="comment">// 숫자 원소가 5개인 배열</span></span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>, ];  <span class="comment">// 서로 다른 종류의 세 원소가 존재하며 쉼표로 끝난 배열</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열 리터럴의 값으로는 상수뿐 아니라 임의의 표현식도 사용할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = [base, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>]; <span class="comment">// [1024, 1025, 1026, 1027]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열 리터럴은 객체 리터럴 또는 다른 배열 리터럴을 포함할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 배열 리터럴에서 빠진 부분이 존재할 경우, 해당 부분의 원소 값은 <strong>undefined</strong>가 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = [<span class="number">1</span>, ,<span class="number">3</span>]; <span class="comment">// 세 원소 중 가운데 원소 값은 undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,];   <span class="comment">// 두 원소 모두 값은 undefined</span></span><br></pre></td></tr></table></figure></p>
<p>배열 리터럴은 마지막 원소 다음에 쉼표를 추가 할 수 있기 때문에 [,,]의 원소 개수는 2개이다.</p>
<p>배열을 만드는 또 다른 방법은 <strong>Array()</strong> 생성자를 사용하는 것이다.<br>이 생성자는 세 가지 방법으로 호출할 수 있다.</p>
<ul>
<li><p><strong>인자 없이 호출하는 방법</strong><br>이 방법은 아무 원소도 없는 빈 배열을 생성하고, 생성된 배열은 배열 리터럴(<code>[]</code>)와 동일하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>배열의 길이를 의미하는 숫자 값을 인자로 주어 호출하는 방법</strong><br>이 방법은 생성자의 인자로 전달받은 숫자 값 만큼 원소를 갖는 배열을 생성한다.<br>이러한 방법은 배열에 저장될 원소의 크기를 알고 있고, 미리 공간을 할당할 때 사용한다.<br>이때 배열에는 어떠한 값도 저장되지 않고, 배열의 인덱스 프로퍼티 값(“0”, “1” 등등) 역시 존재하지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); <span class="comment">// length가 10인 배열</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>두 개 이상의 원소, 또는 숫자가 아닌 원소 값 하나를 명시적으로 지정하는 방법</strong><br>이 방법은 생성자의 인자 값들이 배열의 원소가 된다.<br>배열의 생성자를 사용하는 것보다 배열 리터럴을 사용하는 편이 간단하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">"test"</span>); <span class="comment">// [5,4,3,2,1,"test"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<h1 id="배열의-원소-읽고-쓰기"><a href="#배열의-원소-읽고-쓰기" class="headerlink" title="배열의 원소 읽고 쓰기"></a>배열의 원소 읽고 쓰기</h1><p>배열의 각 원소에 접근할 때에는 <code>[]</code>연산자를 사용한다.<br><code>[]</code>연산자 왼쪽에는 배열 참조 변수가 와야 하며,<br><code>[]</code> 안에는 음이 아닌 정수 값으로 평가되는 임의의 표현식이 위치할 수 있다.<br>이 구문은 배열에서 원소를 읽거나 쓸 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"world"</span>];  <span class="comment">// 하나의 원소가 있는 배열 a</span></span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];   <span class="comment">// a 배열의 0번째 원소 값을 읽고, 변수 value에 할당</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;        <span class="comment">// a 배열의 1번째 원소에 값을 할당</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;           <span class="comment">// a 배열의 2번째 원소에 값을 할당</span></span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">"hello"</span>;   <span class="comment">// a 배열의 3번쨰 원소에 값을 할당</span></span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];     <span class="comment">// a 배열의 a[i]번째 원소에 a[0]번째 원소 값을 읽고, 할당</span></span><br><span class="line"></span><br><span class="line">a;                  <span class="comment">// ["world", 3.14, 3, "world"]</span></span><br></pre></td></tr></table></figure></p>
<p>배열은 <strong>객체의 특별한 종류</strong>다.<br>배열의 <code>[]</code> 구문은 객체 프로퍼티 접근 때 쓰는 <code>[]</code>와 똑같이 동작한다.<br>자바스크립트는 사용자가 명시한 <strong>숫자 배열 인덱스를 문자열 형태로 바꿔서</strong> 프로퍼티 이름으로 사용한다.<br>예를 들어, 인덱스가 1이라면 문자열 ‘1’로 바꿔서 프로퍼티에 접근하는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;   <span class="comment">// 빈 객체</span></span><br><span class="line">o[<span class="number">1</span>] = <span class="string">"one"</span>; <span class="comment">// 숫자 인덱스 값으로 객체에 값을 할당</span></span><br><span class="line">o;            <span class="comment">// &#123;1: "one"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>배열이 일반 객체와 다른 점은 속성 이름으로 2^32 보다 작은 양수를 사용할 때,<br>자동으로 length 프로퍼티의 값을 바꾼다는 것이다.<br>앞의 예제 배열 a처럼, 한 개의 원소로 배열을 만들고 1,2,3 인덱스의 값을 할당했다.<br>처음 a의 length는 1이였지만, 결과적으로 4로 바뀌었다.</p>
<p>배열의 인덱스(array index)와 객체 프로퍼티 이름(object property name)을 올바르게 구별할 줄 알아야 좋다.<br>모든 인덱스 값은 프로퍼티 이름이지만, 프로퍼티 이름은 0과 2^32 - 1 사이의 정수여야만 딘덱스가 될 수 있다.<br><strong>모든 배열은 객체이므로, 어떤 이름의 프로퍼티라도 자유롭게 만들 수 있다.</strong><br>하지만 배열에는, <strong>프로퍼티 가운데 인덱스인 것들을 사용하면 length 프로퍼티의 값이 자동으로 갱신</strong>되는 기능을 갖추고 있다.</p>
<p>배열 첨자로 음수나, 정수가 아닌 수들을 사용할 수 있기는 하다.<br>그런데 이 경우에는 <strong>숫자가 문자열로 변환</strong>되고, <strong>변환된 문자열이 배열 객체의 프로퍼티 이름으로 사용</strong>된다.<br>이때 프로퍼티 이름이 양수가 아니기 때문에, 배열의 인덱스가 아닌 <strong>일반 프로퍼티 이름</strong>으로 취급된다.</p>
<p>반대로, 배열 첨자로 양의 정수가 담긴 문자열을 사용하면, 일반 프로퍼티가 아닌 <strong>배열 인덱스</strong>로 쓰인다.<br>소수점 아래가 없는 부동 소수점 값을 쓸 때도 마찬가지다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>; <span class="comment">// 속성 값 '-1.23'을 만든다.</span></span><br><span class="line">a[<span class="string">"1000"</span>] = <span class="number">0</span>;   <span class="comment">// 1001번째 원소 값으로 0을 할당</span></span><br><span class="line">a[<span class="number">1.000</span>] = <span class="number">2</span>;    <span class="comment">// 1번째 원소 값으로 2를 할당(a[1]과 같다)</span></span><br></pre></td></tr></table></figure></p>
<p>배열의 인덱스가 특별한 종류의 객체 프로퍼티 이름일 뿐이라는 것은,<br>자바스크립트 배열에서는 “out of bounds” 에러가 발생하지 않는다는 뜻이다.<br>(즉, 배열에 대해 경계 검사를 하지 않는다.)</p>
<p>객체에 존재하지 않는 프로퍼티 이름을 찾는다면, 에러가 발생하지 않고 단순히 undefined 값이 반환된다.<br>이러한 성질은 배열에도 적용된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="literal">true</span>, <span class="literal">false</span>];  <span class="comment">// 두 개의 원소를 가진 배열</span></span><br><span class="line">a[<span class="number">2</span>];               <span class="comment">// undefined : 해당 인덱스에 원소가 없다</span></span><br><span class="line">a[<span class="number">-1</span>];              <span class="comment">// undefined : '-1'이라는 속성 이름에 해당하는 값이 없다</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>모든 배열은 객체다.</strong><br>따라서 배열은 <strong>객체의 프로토타입으로부터 원소들을 상속받을 수 있다.</strong><br><em>ECMAScript 5</em> 에서 배열은 심지어 getter와 setter 메서드를 통해 정의된 원소도 가질 수 있다.<br>그러나 배열 원소를 상속받거나 원소 질의나 생성에 getter/setter를 쓰면 최적화되지 않은 코드를 쓰게 된다고 생각해야 한다.<br>그런 배열의 원소에 접근하는 데 드는 시간은 일반 객체에 프로퍼티 조회시간과 비슷하다.<br><br><br><br></p>
<h1 id="희소배열"><a href="#희소배열" class="headerlink" title="희소배열"></a>희소배열</h1><p>희소배열(sparse array)은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말한다.<br>보통 배열의 length 프로퍼티는 배열에 속한 원소의 개수를 의미한다.<br>그러나, 희소배열의 경우, length 프로퍼티 값은 배열에 속한 원소의 개수보다 항상 크다.<br><strong>Array()</strong> 생성자를 통해 배열을 만들거나, 단순히 배열의 크기보다 큰 인덱스에 값을 할당하여 만들 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);   <span class="comment">// 원소가 없지만 a.length는 5인 배열</span></span><br><span class="line">a = [];             <span class="comment">// length가 0인 빈 배열</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;        <span class="comment">// 배열의 1000번째에 원소 0을 할당했다.</span></span><br><span class="line">                    <span class="comment">// 원소는 하나 뿐이지만, length는 1001</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열은 보통 배열보다 일반적으로 느리고, 메모리를 많이 사용할 뿐 아니라,<br>원소를 찾는 데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래걸린다.</p>
<p><strong>배열 리터럴 사용 시 값을 명시하지 않는 방법으로는 희소배열을 만들 수 없다.</strong><br>해당 원소의 값이 undefined가 되기 때문이다.<br>이는 배열에 원소가 아예 존재하지 않는 것이 아니다.<br><code>in</code> 연산자를 사용하면 차이점을 알 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [,,,];          <span class="comment">// 세 개의 원소가 undefined 인 일반 배열</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);   <span class="comment">// 원소가 없는 희소 배열</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a; <span class="comment">//true; a의 0번째 인덱스에 원소가 존재한다(undefined)</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> b; <span class="comment">//false; b의 0번째 인덱스에 원소가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열은 자바스크립트 배열을 이해하는데 매우 중요하다.<br>하지만, 실무에서는 쓰이지 않는다.<br><br><br><br></p>
<h1 id="배열의-길이"><a href="#배열의-길이" class="headerlink" title="배열의 길이"></a>배열의 길이</h1><p>모든 배열에는 <strong>length</strong> 프로퍼티가 있다.<br>이는 자바스크립트 <strong>객체와 배열을 구분하는 중요한 특징</strong>이다.<br>희소배열이 아닌 배열의 경우, length 프로퍼티 값은 배열의 원소 개수를 의미하며,<br>이는 <strong>배열에서 가장 큰 인덱스 값보다 하나 더 큰 값</strong>이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].length;              <span class="comment">// 원소가 없는 배열이므로 length는 0</span></span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].length;   <span class="comment">// 가장 큰 인덱스는 2이고, length 는 3</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열의 경우 length 프로퍼티는 항상 원소의 개수보다 큰데,<br>이는 배열의 length가 배열에 속한 모든 원소의 인덱스보다 항상 크다는 의미이다.<br>즉, 희소배열과 관계없이 원소의 인덱스는 배열의 length보다 절대로 크거나 같을 수 없다.<br>이 불변식(invariant)를 유지하기 위해, 배열은 두 가지 독특한 작동을 한다.</p>
<ul>
<li><p>첫 번째,<br>만약 배열에 배열의 현재 크기보다 같거나 큰 인덱스 i를 갖는 원소를 삽입하는 경우,<br>배열의 length 값은 자동으로 i+1로 설정된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.length;   <span class="comment">//3</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">a.length;   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>두 번째,<br>만약 음이 아니며 기존 length 값보다 작은 정수 n을 length 값으로 할당할 경우,<br>n번째 인덱스보다 크거나 같은 위치에 있는 원소는 배열에서 <strong>삭제</strong>된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.length = <span class="number">3</span>;   <span class="comment">// a[3]과 그보다 큰 인덱스를 가진 원소는 모두 삭제</span></span><br><span class="line">a;              <span class="comment">// [1,2,3]</span></span><br><span class="line">a.length = <span class="number">0</span>;   <span class="comment">// a[0]과 그보다 큰 인덱스를 가진 원소는 모두 삭제</span></span><br><span class="line">a;              <span class="comment">// []</span></span><br><span class="line">a.length = <span class="number">5</span>;   <span class="comment">// length는 5이지만, 배열안에 원소가 없다</span></span><br><span class="line">a;              <span class="comment">// [empty x 5]; length는 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>배열의 프로퍼티 값은 기존 값보다 크게 설정할 수 있다.<br>이는 실제로 배열에 새로운 원소를 추가하지는 않고, 단지 배열의 끝부분에 빈 공간을 생성한다.</p>
<p><em>ECMAScript 5</em>에서는 배열의 length 프로퍼티 값을 <strong>Object.defineProperty()</strong> 메서드를 사용해 읽기 전용(read-only)으로 만들 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 세 개의 원소를 가진 배열, lenth는 3</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">"length"</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);  <span class="comment">// length 속성 값을 읽기 전용으로 변경</span></span><br><span class="line">a.length = <span class="number">0</span>;   <span class="comment">// length 속성 값을 변경해도 배열의 length는 변하지 않는다</span></span><br></pre></td></tr></table></figure></p>
<p>이와 마찬가지로, 배열의 어떤 원소를 설정 불가능(non-configurable)하게 만든다면, 그 원소는 지울 수 없다.<br>따라서 배열의 length 프로퍼티 값 역시 해당 원소의 인덱스보다 작은 값으로 설정할 수 없다.<br><br><br><br></p>
<h1 id="배열에-원소를-추가하거나-삭제하기"><a href="#배열에-원소를-추가하거나-삭제하기" class="headerlink" title="배열에 원소를 추가하거나 삭제하기"></a>배열에 원소를 추가하거나 삭제하기</h1><p>배열에 원소를 추가하는 방법은 새 인덱스에 값을 할당하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];     <span class="comment">// 빈 배열</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"zero"</span>;  <span class="comment">// 0번째에 값을 할당</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"one"</span>;   <span class="comment">// 1번째에 값을 할당</span></span><br><span class="line">a;              <span class="comment">// ["zero", "one"]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>직접 할당하는 방법 외에, <strong>push()</strong> 메서드를 사용해 배열의 끝에 원소를 추가하는 방법도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];           <span class="comment">// 빈 배열</span></span><br><span class="line">a.push(<span class="string">"zero"</span>);       <span class="comment">// 배열의 끝에 원소를 추가</span></span><br><span class="line">a.push(<span class="string">"one"</span>, <span class="string">"two"</span>); <span class="comment">// 배열의 끝에 원소를 두 개 추가</span></span><br><span class="line">a;                    <span class="comment">// ["zero","one","two"]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>push()</strong> 메서드로 배열의 끝에 원소를 추가하는 것은 a[a.length]에 값을 할당하는 것과 같다.<br><strong>unshift()</strong> 메서드를 사용하면 배열의 앞쪽에 원소를 추가할 수 있다.<br>이때 기존 원소들은 인덱스 값이 하나씩 커지면서 옆으로 밀려난다.</p>
<p>객체에서 프로퍼티를 지울 떄와 마찬가지로 <code>delete</code> 연산자로 배열의 원소도 지울 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];    <span class="comment">// 인덱스가 1인 원소를 제거</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a;         <span class="comment">// false : 인덱스가 1인 원소가 제거되었기 때문</span></span><br><span class="line">a.length;       <span class="comment">// 3 : 원소는 제거되었지만 length는 변하지 않음</span></span><br></pre></td></tr></table></figure></p>
<p>배열의 특정 원소를 지우는 것은, 해당 원소에 undefined 값을 할당하는 것과 의미가 비슷하다.<br>배열의 원소에 <code>delete</code>를 사용하더라도 배열의 length 프로퍼티 값은 바뀌지 않는다.<br>이는 원소가 지워지면서 생기는 공백을 다른 원소가 대신 하지 않는다는 의미이다.<br>즉 배열에서 원소를 delete해버리면 해당 배열은 <strong>희소배열</strong>이 된다.</p>
<p>배열의 length 프로퍼티의 값을 줄이면 <strong>배열의 끝에서부터 원소를 삭제</strong>할 수 있다.<br>배열에는 <strong>pop()</strong> 메서드가 있는데(<strong>push()</strong>와 쌍), 이는 배열의 length를 하나 줄이고, 삭제된 값을 <strong>반환</strong>한다.</p>
<p><strong>배열의 앞에서 삭제</strong>하는 메서드도 있다.<br><strong>shift()</strong>는 (<strong>unshift()</strong>와 쌍) delete와 다르게 모든 원소의 인덱스 값을 하나씩 감소시킨다.</p>
<p><strong>splice()</strong>는 배열의 원소를 추가, 삭제, 대치하는 범용 메서드다.<br>배열의 length 프로퍼티 값을 바꾸고, 배열에 속한 원소의 인덱스를 증가시키거나 감소시킬 수 있다.<br><br><br><br></p>
<h1 id="배열-순회하기"><a href="#배열-순회하기" class="headerlink" title="배열 순회하기"></a>배열 순회하기</h1><p>배열을 순회하는 가장 일반적인 방법은 <code>for</code> 루프를 사용하는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);  <span class="comment">// 객체 o에서 프로퍼티 이름을 배열로 가져온다.</span></span><br><span class="line"><span class="keyword">var</span> values = [];            <span class="comment">// 빈 배열</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>중첩 루프 또는 성능에 민감한 컨텍스트에서 배열을 순회할 때는 매번 배열의 length를 가져오는 것보다,<br>한 번만 가져와서 사용하도록 루프를 최적화 해야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>위 예제들은 배열에 원소가 가득 차 있고, 각 원소는 적절한 데이터를 가지고 있다고 가정한다.<br>만약 희소배열이나 적절한 데이터가 없는 경우 반드시 테스트를 해야한다.</p>
<p>null이나 undefined 또는 빈 원소를 제외하고 싶다면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;    <span class="comment">// null이나 undefiend 및 빈 원소일 경우 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 undefiend 와 빈 원소만 건너뛰고 싶다면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;  <span class="comment">// 원소 값이 undefined 이거나 빈 원소일 경우 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>아무 원소도 없는 인덱스는 건너뛰지만, 윈소 값이 undefined인 경우는<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>;  <span class="comment">// 빈 원소는 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];        <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];       <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열에 대해 <code>for</code> 루프를 사용하듯, <code>for/in</code> 루프도 사용할 수 있다.<br><code>for/in</code> 루프는 배열의 인덱스를 포함한 프로퍼티 이름들을 한 번에 하나씩 루프 변수에 할당한다.<br>존재하지 않는 인덱스는 루프에 나타나지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = sparseArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><code>for/in</code> 루프는 상속받은 프로퍼티 이름까지 나온다.<br>예를 들어, <strong>Array.prototype</strong>에 추가된 메서드의 이름까지 알려준다.<br>따라서 원하지 않는 상속받은 프로퍼티를 제외하는 테스트를 하지 않았다면,<br><code>for/in</code> 루프를 사용하지 말아야 한다.<br><code>for/in</code> 루프를 사용하고 상속받은 프로퍼티를 제외하려면 아래와 같이한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상속받은 프로퍼티는 제외</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>; <span class="comment">// 상속받은 속성은 건너뜀</span></span><br><span class="line">                                        <span class="comment">// hasOwnProperty()는 상속받은 프로퍼티가 나오지 않음</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//음의 정수로 된 프로퍼티는 제외</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><em>ECMAScript</em> 에서는 <code>for/in</code> 루프가 객체의 프로퍼티들을 어떤 순서로 순회해야 하는지 정해놓고 있지 않다.<br>일반적으로 대부분 구현체는 배열의 원소를 오름차순으로 순회하지만, 항상 그렇지는 않다.<br>만약 배열이 객체 프로퍼티와 배열의 원소 둘다 가지고 있다면, 프로퍼티 이름은 그 크기 순서가 아니라 생성된 순서대로 반환될 수도 있다.<br>순회하는 순서가 중요하다면, <code>for/in</code> 루프보다 <code>for</code> 루프를 사용해야한다.</p>
<p><em>ECMAScript 5</em>에는 배열을 순회하는 다양한 메서드가 추가되었다.<br>사용자가 정의한 함수에 배열의 원소가 <strong>인덱스 순서대로 하나씩 넘어오도록 하여 배열을 순회</strong>하는 형태다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];     <span class="comment">// 순회에 사용될 배열</span></span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;       <span class="comment">// 배열의 각 원소를 제곱한 값의 합계</span></span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sumOfSquares += x*x;    <span class="comment">// 원소 값의 제곱을 sumOfSquares에 누적</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sumOfSquares;               <span class="comment">// 55</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="다차원-배열"><a href="#다차원-배열" class="headerlink" title="다차원 배열"></a>다차원 배열</h1><p>자바스크립트는 실제로 다차원 배열을 지원하지 않는다.<br>그러나, 배열의 병ㄹ을 사용해 다차원 배열을 흉내 낼 수 있다.<br>배열 내의 배열에 있는 원소에 접근하기 위해서는 단순히 <code>[]</code>연산자를 두 번 사용하면 된다.</p>
<p>예를 들어, matrix가 배열의 배열이라 가정하자.<br>matrix[x]의 모든 배열의 원소는 숫자 배열이다.<br>이 숫자 배열의 특정 숫자에 접근하기 위해서는 matrix[x][y]와 같이 쓸 수 있다.</p>
<p>구구단을 작성하기 위해 2차원 배열을 사용하는 방법은 다음과 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다차원 배열</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">// 구구단 표의 10개의 행을 만든다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);   <span class="comment">// 각 행에 10개의 열을 만든다</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열을 초기화</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; table.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; table[row].length; col++) &#123;</span><br><span class="line">        table[row][col] = row * col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 * 7 을 계산하기 위한 구구단 표를 사용</span></span><br><span class="line"><span class="keyword">var</span> product = table[<span class="number">5</span>][<span class="number">7</span>];  <span class="comment">// 35</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="배열-메서드"><a href="#배열-메서드" class="headerlink" title="배열 메서드"></a>배열 메서드</h1><p><em>ECMAScript 3</em>의 <strong>Array.prototype</strong>은 배열을 다루는 데 필요한 여러 종류의 함수를 정의한다.<br>정의된 함수들은 모든 배열에서 <strong>메서드</strong>로 사용할 수 있다.<br><br></p>
<h2 id="join"><a href="#join" class="headerlink" title="- join()"></a>- join()</h2><p><strong>Array.join()</strong> 메서드는 배열의 모든 원소를 <strong>문자열로 변환</strong>하고, 변화한 문자들을 <strong>이어 붙인 결과</strong>를 반환한다.<br>이때 결과로 반환되는 문자열에서 배열의 원소들을 구별하기 위해 <strong>구분자(separator)</strong> 문자열을 사용한다.<br>별도로 구분자 문자열을 지정하지 않으면, <strong>쉼표(<code>,</code>)가 기본값</strong>으로 사용된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 세 개의 원소를 가진 배열을 생성</span></span><br><span class="line">a.join();           <span class="comment">// "1,2,3"</span></span><br><span class="line">a.join(<span class="string">" "</span>);        <span class="comment">// "1 2 3"</span></span><br><span class="line">a.join(<span class="string">""</span>);         <span class="comment">// "123"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">// 길이가 10인 빈 배열을 생성</span></span><br><span class="line">b.join(<span class="string">"-"</span>);            <span class="comment">// "---------": 아홉 개의 하이픈 문자열</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>Array.join()</strong> 메서드는 String.split() 메서드와는 반대로 작동한다.<br><strong>String.split()</strong> 메서드는 문자열을 조각들로 <strong>분리</strong>하고,<br>이 조각들을 <strong>원소로 하는 배열을 생성</strong>한다.<br><br></p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="- reverse()"></a>- reverse()</h2><p><strong>Array.reverse()</strong> 메서드는 배열의 원소 순서를 반대로 뒤집어 반환한다.<br>이 작업은 배열 안에서 직접 수행된다.<br>즉, 순서가 뒤바뀐 새로운 배열을 생성하는 것이 아니라, <strong>이미 존재하는 배열 안에서 순서를 뒤바꾼다.</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.reverse();</span><br><span class="line">a;        <span class="comment">// [3, 2, 1]</span></span><br><span class="line">a.join(); <span class="comment">// "3,2,1"</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="- sort()"></a>- sort()</h2><p><strong>Array.sort()</strong> 메서드는 배열 안의 원소들을 정렬하여 반환한다.<br>sort() 메서드를 별도의 전달인자 없이 호출하면, 배열 안의 원소들을 알파벳순으로 정렬한다.<br>필요한 경우, 비교를 위해 원소들이 잠시 문자열로 변환된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"apple"</span>);</span><br><span class="line">a.sort();   <span class="comment">// ["apple","banana","cherry"]</span></span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">", "</span>);</span><br><span class="line">s;          <span class="comment">// "apple, banana, cherry"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열에 undefined 원소가 존재하면, 이 원소는 배열의 <strong>끝부분으로 정렬</strong>된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"banana"</span>,<span class="literal">undefined</span>, <span class="string">"cherry"</span>, <span class="string">"apple"</span>);</span><br><span class="line">a.sort();   <span class="comment">// ["apple","banana","cherry",undefined]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>알파벳순이 아니라 다른 순서로 배열을 정렬하려면, sort() 메서드의 전달인자를 통해 <strong>비교 함수</strong>를 직접 명시해주어야 한다.</p>
<p>비교 함수는 전달인자를 두 개 받아서, 정렬된 배열에서 어떤 것이 먼저 나타나야 하는지 판단한다.<br>만약 <strong>첫 번쨰 인자가 두 번째 보다 먼저 나타나야 한다면, 비교 함수는 0보다 작은 숫자를 반환</strong>해야 한다.<br>(두 번째 인자가 먼저 나타나야 한다면, 비교 함수는 0보다 큰 숫자를 반환해야 한다)<br>만약 두 값이 동등하다면(두 값의 순서를 정하는 것이 무의미하다면) 0을 반환해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();   <span class="comment">// 111, 222, 33, 4 : 알파벳 순서이므로</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b; <span class="comment">// 0보다 작거나, 크거나 0을 반환</span></span><br><span class="line">&#125;);             <span class="comment">// 4, 33, 111, 222</span></span><br></pre></td></tr></table></figure></p>
<p>여기서는 <strong>익명 함수 표현식(unnamed function expression)</strong>을 사용하였다.<br>비교 함수는 한 번만 사용되기 때문에 함수에 이름을 부여하지 않아도 되기 때문이다.</p>
<p>배열 원소를 정렬하는 또 다른 예로, 대소문자를 구분하지 않는 알파벳순으로 배열을 정렬할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'ant'</span>, <span class="string">'Bug'</span>, <span class="string">'cat'</span>, <span class="string">'Dog'</span>];</span><br><span class="line">a.sort();   <span class="comment">// ['Bug', 'Dog', 'ang', 'cat'] : 대소문자를 구분한 정렬</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = s.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> b = t.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);         <span class="comment">// ['ant', 'Bug', 'cat', 'Dog'] : 대소문자를 구분하지 않는 정렬</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="concat"><a href="#concat" class="headerlink" title="- concat()"></a>- concat()</h2><p><strong>Array.concat()</strong> 메서드는 기존 배열의 모든 원소에 concat() 메서드의 전달인자들을 추가한 <strong>새로운 배열을 반환</strong>한다.<br>만약 concat() 메서드의 전달인자로 배열을 전달하면, 이 배열 안의 원소들을 꺼내어 반환하는 배열에 추가한다.<br>하지만 배열의 원소 중에 배열이 있는 중첩 배열의 경우에는, 중첩된 배열의 원소까지 꺼내지는 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);         <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>]);        <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]);  <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]);  <span class="comment">// [1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="slice"><a href="#slice" class="headerlink" title="- slice()"></a>- slice()</h2><p><strong>Array.slice()</strong> 메서드는 부분 배열(subaraay)을 반환한다.<br>여기서 <strong>부분 배열</strong>이란 배열에서 잘라낸 원소들을 담은 새 배열이다.</p>
<blockquote>
<p>slice(잘라내는 것을 시작할 위치, 잘라내는 것을 끝낼 위치)</p>
</blockquote>
<p>slice() 메서드는 전달인자를 두 개 받는데, 각 인자는 반환될 부분의 처음과 끝을 명시한다.<br>반환되는 배열은 첫 번째 전달인자가 지정하는 위치부터 두 번째 전달인자가 지정하는 위치 이전까지의 모든 원소를 포함한다.<br>만약 전달인자를 하나만 명시하면, 그 위치에서 배열 끝까지의 모든 원소를 포함하는 부분 배열을 반환한다.<br>만약 전달인자가 음수라면, 배열의 마지막 원소에서부터의 상대적인 위치를 가리키는 것이다.<br>(전달인자가 -1이라면 마지막 원소를, -3 이라면 마지막 원소로부터 앞쪽으로 세번째 원소를 가르킨다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>);   <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);     <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">-1</span>);  <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>,<span class="number">-2</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="splice"><a href="#splice" class="headerlink" title="- splice()"></a>- splice()</h2><p><strong>Array.splice()</strong> 메서드는 배열의 원소를 <strong>삽입</strong>하거나 원소를 <strong>제거</strong>하려 할 때 범용적으로 사용하는 메서드다.<br>splice() 메서드는 slice()나 concat() 메서드와는 달리 <strong>호출 대상 배열을 바로 수정</strong>한다.</p>
<p>splice() 메서드는 배열의 원소를 삭제하거나 배열에 새로운 원소를 삽입하는데 사용할 수 있으며, 이 두 작업을 동시에 수행할 수도 있다.<br>배열 안의 원소들을 빈틈없이 배치하기 위해서, 원소를 추가하거나 삭제할 때 필오에 따라 나머지 원소들의 인덱스 값이 증가하거나 감소할 수 있다.</p>
<blockquote>
<p>splice(삽입 또는 삭제를 시작할 위치, 삭제할 원소의 개수, 삽입할 원소…)</p>
</blockquote>
<p>splice()의 첫 번째 전달인자는 배열상에서 <strong>삽입 혹은 삭제 작업을 시작할 위치</strong>를 지정하며,<br>두 번쨰 전달인자는 배열에서 <strong>삭제할 원소의 개수</strong>를 지정한다.<br>두 번쨰 전달인자를 지정하지 않으면 첫 번째 전달인자로 지정한 배열의 시작위치에서 마지막 원소까지 전부 삭제한다.<br>splice()는 이렇게 삭제한 배열을 반환하며, 만약 삭제된 원소가 하나도 없다면 빈 배열을 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);    <span class="comment">// [5,6,7,8]을 반환</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">// [2,3]을 반환</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">1</span>);  <span class="comment">// [4]를 반환</span></span><br><span class="line">a;              <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>splice()의 처음 두 전달인자는 배열에서 삭제할 원소들을 지정하는 데 사용되었다.<br>세 번째 전달인자부터는 배열에 새롭게 <strong>삽입</strong>할 원소들을 지정하는데 사용되며, 이때 삽입 작업은 첫 번째 전달인자로 지정된 시작 위치부터 수행된한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">'b'</span>);  <span class="comment">// []를 반환</span></span><br><span class="line">a;                      <span class="comment">// [1,2,'a','b',3,4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>);  <span class="comment">// ['a','b']를 반환</span></span><br><span class="line">a;                      <span class="comment">// [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>concat() 메서드와는 달리 splice() 메서드는 전달인자로 배열이 전달되면, 그 배열의 원소들을 꺼내어 삽입하지 않고 <strong>배열 그 자체를 삽입</strong>한다.<br><br></p>
<h2 id="push-와-pop"><a href="#push-와-pop" class="headerlink" title="- push()와 pop()"></a>- push()와 pop()</h2><p>push()와 pop() 메서드를 사용하면 배열을 마치 <strong>스택</strong>처럼 조작할 수 있다.</p>
<p>push() 메서드는 하나 이상의 원소들을 배열의 끝부분에 <strong>삽입</strong>하고, 배열의 새로운 <strong>length 값을 반환</strong>한다.<br>pop() 메서드는 배열의 마지막 원소를 <strong>제거</strong>하고 배열의 length 값을 감소시킨 후, 배열에서 <strong>제거한 원소를 반환</strong>한다.</p>
<p>이 두 메서드는 새로운 배열을 만들어 반환하는 것이 아니라 배열 그 자체를 변화시킨다.<br>push()와 pop()을 함께 사용하면 자바스크립트의 배열로 <strong>FILO(선입흐출)</strong> 스택을 구현할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];     <span class="comment">// stack: []</span></span><br><span class="line">stack.push(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// stack: [1,2]     | return 2 (stack의 length)</span></span><br><span class="line">stack.pop();        <span class="comment">// stack: [1]       | return 2</span></span><br><span class="line">stack.push(<span class="number">3</span>);      <span class="comment">// stack: [1,3]     | return 2 (stack의 length)</span></span><br><span class="line">stack.pop();        <span class="comment">// stack: [1]       | return 3</span></span><br><span class="line">stack.push([<span class="number">4</span>,<span class="number">5</span>]);  <span class="comment">// stack: [1,[4,5]] | return 2 (stack의 length)</span></span><br><span class="line">stack.pop();        <span class="comment">// stack: [1]       | return [4,5]</span></span><br><span class="line">stack.pop();        <span class="comment">// stack: []        | return 1</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="unshift-와-shift"><a href="#unshift-와-shift" class="headerlink" title="- unshift()와 shift()"></a>- unshift()와 shift()</h2><p>unshift()와 shift() 메서드는 push()와 pop()과 매우 유사하게 동작하지만,<br>배열의 끝이아니라 배열의 맨 앞에서 원소를 추가하고 제거한다는 점이 다르다.</p>
<p>unshift() 메서드는 하나 혹은 그 이상의 원소들을 배열의 맨 앞에 <strong>추가</strong>하고, 추가된 원소만큼 공간을 만들기 위해 기존의 배열 원소들을 인덱스가 높은 방향으로 옮긴 후,<br>배열의 <strong>새로운 length 값을 반환</strong>한다.<br>shift() 메서드는 배열의 첫 번째 원소를 제거한 후, 나머지 배열 원소들을 전부 앞으로 옮겨 첫 번째 원소가 제거되면서 생긴 빈 공간을 메우고,<br>배열에서 <strong>제거한 원소를 반환</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];         <span class="comment">// a: []</span></span><br><span class="line">a.unshift(<span class="number">1</span>);       <span class="comment">// a: [1]         | return 1</span></span><br><span class="line">a.unshift(<span class="number">22</span>);      <span class="comment">// a: [22,1]      | return 2</span></span><br><span class="line">a.shift();          <span class="comment">// a: [1]         | return 22</span></span><br><span class="line">a.unshift(<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">// a: [3,[4,5],1] | return 3</span></span><br><span class="line">a.shift();          <span class="comment">// a: [[4,5],1]   | return 3</span></span><br><span class="line">a.shift();          <span class="comment">// a: [1]         | return [4,5]</span></span><br><span class="line">a.shift();          <span class="comment">// a: []          | return 1</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>unshift()의 전달인자로 여러 개의 원소들을 한꺼번에 배열에 추가하면 예상치 못한 결과를 얻을 수도 있다는 것에 주의하자.<br>unshift()는 전달인자의 원소들을 뺴내어 하나씩 배열에 추가하는 대신, 모든 전달인자를 한꺼번에 (splice() 메서드와 마찬가지) 배열에 추가한다.<br>이는 unshift()에 의해 변형된 새로운 배열의 원소 순서와 unshift() 메서드의 전달인자의 원소 순서가 동일하다는 의미다.<br>(만약 unshift()가 원소들을 한 번에 하나씩 배열에 추가하게 동작했다면, 원소의 순서는 반대로 저장될 것이다.)</p>
<h2 id="toString-과-toLocaleString"><a href="#toString-과-toLocaleString" class="headerlink" title="- toString()과 toLocaleString()"></a>- toString()과 toLocaleString()</h2><p>자바스크립트 객체와 마찬가지로 배열에도 toString() 메서드가 있다.<br>배열의 <strong>toString()</strong> 메서드는 우선 <strong>배열의 모든 원소를 문자열로 변환</strong>하고 (필요에 따라 각 원소의 toString() 메서드가 호출),<br><strong>이 문자열들을 쉼표(<code>,</code>)로 분리한 목록을 반환</strong>한다.<br>변환된 문자열은 대괄호 문자나 배열 값의 종류를 분류하는 구분자(delimiter)를 포함하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString();         <span class="comment">// "1,2,3"</span></span><br><span class="line">[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>].toString();   <span class="comment">// "a,b,c"</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">"c"</span>]].toString();     <span class="comment">// "1,2,c"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>별도의 전달인자를 지정하지 않고 join() 메서드를 호출하면 toString()과 동일한 결과를 얻을 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].join(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>toLocaleString()</strong>은 toString()의 지역화 버전이다.<br>이 메서드는 우선 배열의 각 원소들을 그 원소의 toLocaleString() 메서드를 사용해 변환하고,<br>변환된 문자열들을 지역화된(또는 각 구현체가 정의하는) 구분자 문자열(separator string)로 연결하여 반환한다.<br><br><br><br></p>
<h1 id="ECMAScript-5-배열-메서드"><a href="#ECMAScript-5-배열-메서드" class="headerlink" title="ECMAScript 5 배열 메서드"></a>ECMAScript 5 배열 메서드</h1><p><em>ECMAScript 5</em>는 배열을 순회, 매핑, 필터링, 테스팅, 감소(reducing), 검색하기위한 아홉 가지 새로운 메서드를 정의하고 있다.<br>대부분의 메서드들은 <strong>첫 번째 전달인자로 함수</strong>를 받는데, 이는 배열의 각 원소마다 한 번씩 실행하거나 일부 원소들에 한해 실행된다.<br>그런데 만약 배열이 희소배열이라면, 빈 원소의 경우에는 함수를 호출하지 않는다.</p>
<p>대부분의 경우,<br>첫 번째 전달인자로 지정한 함수는 세 개의 전달인자를 가지고 호출되는데,<br>이는 배열의 원소의 값과 인덱스, 마지막으로 배열 그 자체이다.<br>종종, 첫 번째 전달인자만을 사용하고 인덱스와 배열은 무시한다.</p>
<p>첫 인자로 함수를 받는 대부분의 <em>ECMAScript 5</em>의 배열 메서드들은 생략 가능한 두번째 인자를 받는다.<br>만약 두 번째 전달인자를 지정하면, 첫 번쨰 전달인자인 함수는 두 번째 인자의 메서드인 것처럼 호출된다.<br>즉, 두 번째 인자는 첫 번째 전달인자인 함수 안에서 <code>this</code> 키워드의 값으로 사용된다.</p>
<p>전달한 함수의 반환 값은 중요하다. 그러나 그 반환값을 받아 처리하는 방식은 메서드별로 다 다르다.<br><em>ECMAScript 5</em> 배열 메서드는 호출대상 배열을 수정하지 않는다.<br>물론 메서드의 전달인자로 쓰인 함수 안에서는 배열을 수정할 수 있다.<br><br></p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="- forEach()"></a>- forEach()</h2><p><strong>forEach()</strong> 메서드는 배열을 순회하는 메서드로, 첫 번째 인자로 넘긴 함수를 각각의 원소를 대상으로 호출한다.<br>forEach()는 첫 인자로 전달된 함수를 호출할 때 세가지 인자를 넘긴다.<br>각 인자는 배열의 원소 값, 원소의 인덱스 값, 그리고 배열 그 자체이다.</p>
<blockquote>
<p><strong>forEach</strong>(function(배열의 원소 값, 원소의 인덱스 값?, 배열?) { /* */ });</p>
</blockquote>
<p>만약 배열의 원소 값만 사용한다면, 인자를 하나만 받는 함수를 작성하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;    <span class="comment">// 합계는 0부터 시작</span></span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;  <span class="comment">// 각 원소의 값을 꺼내어</span></span><br><span class="line">    sum += value;               <span class="comment">// sum에 더한다</span></span><br><span class="line">&#125;);</span><br><span class="line">sum;            <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123; <span class="comment">// 각 원소의 값을 1씩 증가시킨다</span></span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data;           <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>forEach() 메서드는 <strong>배열의 모든 원소가 순회되기 전에는 종료되지 않는다.</strong><br>즉, 루프에서 사용하는 <code>break</code>문은 사용할 수 없다.<br>만약 루프를 중간에 종료시키려면, 예외를 발생시켜야하고, forEach()는 <code>try</code> 블록 안에서 호출해야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a.forEach(f, t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e === foreach.break) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"StopIteration"</span>);     <span class="comment">// 예외를 발생</span></span><br></pre></td></tr></table></figure></p>
<p>foreach()에 전달된 함수 f가 내부에서 foreach.break 예외를 임의로 발생시키면, 루프는 종료된다.<br><br></p>
<h2 id="map"><a href="#map" class="headerlink" title="- map()"></a>- map()</h2><p><strong>map()</strong> 메서드에 전달한 함수는 forEach()에 전달한 함수와 동일한 형태로 호출된다.<br>하지만 map() 메서드에 <strong>인자로 전달된 함수는 값을 반드시 반환</strong>해야 한다.<br>map() 메서드는 기존의 배열을 수정하지 않고, <strong>새 배열을 반환</strong>한다.<br>만약 배열이 희소배열이라면 반환된 배열 역시 희소배열이 된다.<br>이때 기존 배열과 반환된 배열은 길이가 같고, 빈 원소 개수 역시 같다.<br><br></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="- filter()"></a>- filter()</h2><p><strong>filter()</strong> 메서드는 배열의 일부분을 반환한다.<br>이 메서드에 전달하는 함수는 <strong>조건자 함수(predicate)</strong>여야 한다.<br>즉, <strong>항상 true 또는 false 값을 반환하는 함수</strong>여야 한다.<br>filter()의 조건 함수는 forEach()와 map() 메서드와 동일한 형태로 호출된다.<br>만약 반환값이 true이거나 true로 변환되는 값(truty)이면 조건자 함수에 전달된 값은 <strong>filter</strong>가 반환할 배열에 추가된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">smallValues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line">smallValues; <span class="comment">// [2,1]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>filter()</strong> 메서드는 희소배열의 경우에 빈 원소를 건너뛰기 때문에, 반환되는 배열에는 빈 원소가 없다.<br>따라서, 희소배열의 빈 원소를 제거하고 싶다면 아래와 같이 filter() 사용이 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 희소배열 test</span></span><br><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="number">3</span>];    <span class="comment">// [1,2, empty × 2, undefined, null, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소배열 test의 빈원소를 제거한 배열 a</span></span><br><span class="line"><span class="keyword">var</span> a = sparse.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a;  <span class="comment">// [1,2,undefined,null,3]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 빈 원소가 있던 간격을 좁히고 undefined와 null 값을 갖는 원소도 함께 제거하고 싶다면, 아래와 같이 filter()를 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 희소배열 test</span></span><br><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="number">3</span>];    <span class="comment">// [1,2, empty × 2, undefined, null, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소배열 test의 빈원소와 undefined, null을 제거한 배열 a</span></span><br><span class="line"><span class="keyword">var</span> a = test.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a;  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="every-와-some"><a href="#every-와-some" class="headerlink" title="- every()와 some()"></a>- every()와 some()</h2><p><strong>every()</strong>와 <strong>some()</strong> 메서드는 배열 <strong>조건자 함수(predicate)</strong>다.<br>두 메서드의 인자로 전달하는 함수는 <strong>조건자 함수</strong>이 결과로 true나 false를 반환한다.<br><br><br><strong>every()</strong> 메서드는 수학에서 <em>‘모든 것에 대하여(for all)’</em> 를 뜻하는 정량자 ∀와 같다.<br>즉, <strong>전달인자로 넘긴 함수가 배열의 모든 원소에 대하여 true를 반환하는 경우, every() 메서드는 true를 반환</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">test.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);     <span class="comment">// true: test의 모든 원소 값이 10보다 작으므로</span></span><br><span class="line"></span><br><span class="line">test.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);     <span class="comment">// false: test의 1,3,5는 홀수이므로</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>some()</strong> 메서드는 수학에서 <em>‘일부분에 대하여(there exists)’</em> 를 뜻하는 정량자 ∃와 같다.<br>즉, <strong>전달인자로 넘긴 함수가 배열의 일부 원소에 대하여 true를 반환하는 경우, some() 메서드는 true를 반환</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">test.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);     <span class="comment">// true: test의 원소 중 짝수가 있으므로</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>every()와 some() 메서드는 반환 값이 결정되면 배열의 원소 순회를 중단한다.</p>
<p><strong>some()</strong> 메서드는 조건 함수의 반환 값이 true를 만족하는 첫 번째 원소를 만나면 즉시 true를 반환하므로,<br>모두 false인 경우에만 전체 원소를 순회한다.</p>
<p><strong>every()</strong> 메서드는 조건 함수의 반환 값이 false를 만족하는 첫 번째 원소를 만나면 즉시 false를 반환하므로,<br>모두 true인 경우에만 전체 원소를 순회한다.</p>
<p>수학전 관례에 따르면, 빈 배열인 경우 every() 메서드는 항상 true를, some() 메서드는 항상 false를 반환한다.<br><br></p>
<h2 id="reduce-와-reduceRight"><a href="#reduce-와-reduceRight" class="headerlink" title="- reduce()와 reduceRight()"></a>- reduce()와 reduceRight()</h2><p><strong>reduce()</strong> 와 <strong>reduceRight()</strong> 메서드는 <strong>인자로 주어진 함수를 사용하여 배열의 원소들을 하나의 값으로 결합</strong>한다.<br>이들 메서드는 함수형 프로그래밍에서 일반적으로 통용되는 inject와 fold 연산을 수행한다.<br>(함수형 프로그램에서 fold는 고차 함수의 일종이다. 고차 함수란 함수의 매개변수나 반환 값으로 또 다른 함수를 사용할 수 있는 함수를 말한다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 test의 원소들의 합</span></span><br><span class="line"><span class="keyword">var</span> sum = test.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;,  <span class="number">0</span>); <span class="comment">// 0은 시작 값이다</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 test의 원소들의 곱</span></span><br><span class="line"><span class="keyword">var</span> product = test.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;,  <span class="number">1</span>); <span class="comment">// 1은 시작 값이다</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 test의 원소 중 가장 큰 값을 찾는 것</span></span><br><span class="line"><span class="keyword">var</span> max = test.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;);     <span class="comment">// 두 번째 전달인자를 주지 않으면 첫 번째 값이 시작 값이다.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>reduce()</strong> 메서드는 두 개의 전달 인자를 갖는다.<br>첫 번째 인자는 <strong>배열 원소의 감소 작업을 하는 함수</strong>다.<br>이 <strong>감소 함수(reduction function)</strong>는 어떻게든 배열 원소 중 두 값을 하나로 결합하면서 크기를 줄이고, 마지막 남은 값을 반환한다.<br>위의 예제에서, 각각의 감소 함수들은 차례로 두 원소를 더하면서 줄이고, 곱하면서 줄이고, 두 원소 중 큰 값을 선택하면서 줄인다.<br>두 번째 인자(생략가능한)는 <strong>감소 함수에 전달할 시작 값</strong>이다.<br>(배열의 원소가 감소 함수로 하나씩 전달되기 때문에, 감소 함수 성격에 따라 초기 값이 필요할 수 있다.)</p>
<blockquote>
<p><code>@param</code> 감소함수<br><code>@param?</code> 감소함수에 전달할 시작 값<br><strong>reduce</strong>( function() { }, value)</p>
</blockquote>
<p><strong>reduce()</strong>에 사용되는 함수는 forEach()와 map()과는 조금 다르다.<br>forEach()와 map()에 사용되는 함수에는 원소 값과 인덱스, 배열 자체가 인자로 전달되었다.</p>
<p>하지만 <strong>reduce()</strong>에서 사용하는 함수의 첫 번째 인자는 <strong>함수를 사용해 계산된 값의 누적된 결과</strong>다.<br>그 초기 값은 두 번째 인자로 전달한 값이다.<br>이후의 호출에서는 전 단계 함수 호출에서 반환된 값을 함수의 첫 번째 인자로 사용한다.</p>
<p>위의 ‘원소들의 합’에서 감소 함수에 사용되는 인자 x와 y값은 각각 0과 1이 된다.<br>(두 번째 전달인자가 0이기 때문에, x의 값이 0)<br>첫 번째 단계에서 감소 함수는 0과 1 두 값을 더해 1을 반환한다.<br>다음 단계에서는 전 단계에서 반환된 1과 배열의 두 번째 원소인 2를 x와 y로 사용한다.<br>두 값을 더해 3을 반환하고, 감소 함수는 계속해서 마지막 원소까지 위 과정을 반복한다음 연산을 종료한다.</p>
<p>위의 ‘원소 중 가장 큰 값을 찾는 것’에서 초기 값을 지정하는 두 번째 인자가 없다.<br>이처럼 초기 값 없이 <strong>reduce()</strong> 메서드를 호출할 경우에는 배열의 첫 번째 원소를 초기 값으로 사용한다.<br>즉, 첫 번째 감소 함수 호출 시 사용되는 인자 x와 y자는 각각 배열의 첫 번째와 두 번째 원소가 된다는 의미이다.</p>
<p><strong>reduce()</strong>를 빈 배열에 초기 값 인자없이 호출할 경우, TypeError가 발생한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [];</span><br><span class="line">test.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// Uncaught TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 reduce에 값 하나만 인자로 넘기면(초기 값 인자없이 원소가 하나인 배열과, 초기 값 인자와 빈 배열),<br>메서드는 감소 함수를 호출하지 않고 배열의 원소 또는 초기 값 인자를 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원소가 하나인 배열</span></span><br><span class="line"><span class="keyword">var</span> one = [<span class="number">1</span>];</span><br><span class="line">one.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빈 배열과 초기 값</span></span><br><span class="line"><span class="keyword">var</span> test = [];</span><br><span class="line">test.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>reduceRight()</strong> 메서드는 reduce()와 동작은 같지만, <strong>배열의 끝부터 시작해 반대 방향으로 처리</strong>한다.<br>감소 함수의 피연산자들 중 오른쪽 피연산자(y)의 우선순위가 높다면, <strong>reduceRight()</strong>를 사용해야 할 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^(3^4)</span></span><br><span class="line"><span class="keyword">var</span> big = test.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// accumulator: 4, value: 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, accumulator);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>reduce()</strong>와 <strong>reduceRight()</strong> 메서드는 감소 함수 호출 시 사용할 <code>this</code> 값을 선택 인자로 지정할 수 없다.<br>즉, 선택 초기 값 인자만 지정할 수 있다.<br>만약 감소 함수들 특정 <strong>object</strong>의 메서드로 호출하고 싶다면, <strong>Function.bind()</strong> 메서드를 참고해라.</p>
<p>every()와 some() 메서드는 앞에서 살펴본 배열의 감소 연산이 필요 없다.<br><strong>reduce()</strong> 메서드와 달리 가능한 모든 원소를 순회하지 않고 일찍 종료할 수 있다.</p>
<p><strong>reduce()</strong>와 <strong>reduceRight()</strong> 메서드가 단순히 수치 연산만을 위해 사용되는 것은 아니다.<br>union() 함수는 두 객체가 가지 공통 속성들을 새 객체에 담아 반환한다.<br>이 함수는 두 객체를 사용해 새로운 객체를 반환한다는 점에서 감소 함수와 유사하다.<br>따라서 <strong>reduce()</strong>를 사용하면 여러 객체를 합칠 수 있도록 union()을 일반화할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 p의 열거 가능한 프로퍼티들을 객체 o에 복사 후 반환</span></span><br><span class="line"><span class="comment"> * 만약 객체 o와 p가 같은 이름의 프로퍼티를 갖고 있다면, 객체 o의 프로퍼티를 재정의한다</span></span><br><span class="line"><span class="comment"> * 이 함수는 getter/setter 메서드와 프로퍼티 속성까지는 복사하지 않는다</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(prop <span class="keyword">in</span> p) &#123;         <span class="comment">//p의 열거가능한 모든 프로퍼티</span></span><br><span class="line">        o[prop] = p[prop];   <span class="comment">//o의 프로퍼티로 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 객체 o와 p가 가진 프로퍼티들을 새 객체에 담아 반환</span></span><br><span class="line"><span class="comment"> * 만약 같은 이름의 프로퍼티가 있다면 객체 p의 프로퍼티 값을 사용</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> extend(extend(&#123;&#125;, o), p);    <span class="comment">//1. 새로 생성한 객체에 o의 프로퍼티를 추가</span></span><br><span class="line">                                        <span class="comment">//2. 새로 생성한 객체에 p의 프로퍼티를 추가</span></span><br><span class="line">                                        <span class="comment">//   동일한 프로퍼티 이름이 있는경우 새로 생성한 객체의 프로퍼티를 재정의</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union); <span class="comment">// &#123;x:1, y:2, z:3&#125; : union이 감소 함수로 사용된다</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>두 객체가 같은 속성을 가지고 있을 경우, union() 함수는 처음 발견된 속성의 값을 사용한다.<br>따라서 <strong>reduce()</strong>와 <strong>reduceRight()</strong>를 union()과 함께 사용할 경우, 그 결과는 다를 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>, <span class="attr">a</span>:<span class="number">3</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> leftUnion = objects.reduce(union);          <span class="comment">// &#123;x:1, y:2, z:3, a:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rightUnion = objects.reduceRight(union);    <span class="comment">// &#123;x:1, y:2, z:3, a:1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="indexOf-와-lastIndexOf"><a href="#indexOf-와-lastIndexOf" class="headerlink" title="- indexOf()와 lastIndexOf()"></a>- indexOf()와 lastIndexOf()</h2><p><strong>indexOf()</strong>와 <strong>lastIndex()</strong> 메서드는 배열의 원소 중에서 특정한 값을 찾는다.<br>만약 값이 존재하면 해당 값의 <strong>인덱스를 반환</strong>하고, 존재하지 않을 경우 <strong>-1</strong>을 반환한다.<br><strong>indexOf()</strong>는 배열의 처음부터 검색하고, <strong>lastIndexOf()</strong>는 배열의 끝에서부터 검색한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">test.indexOf(<span class="number">1</span>);    <span class="comment">// 1 : 배열의 처음에 가장 근접한 1의 index</span></span><br><span class="line">test.lastIndexOf(<span class="number">1</span>) <span class="comment">// 3 : 배열의 마지막에 가장 근접한 1의 index</span></span><br><span class="line">test.indexOf(<span class="number">3</span>);    <span class="comment">// -1 : 원소의 값중 3이 없다</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>다른 메서드들과 달리 <strong>indexOf()</strong>와 <strong>lastIndexOf()</strong>는 함수를 인자로 받지 않는다.</p>
<blockquote>
<p><code>@param</code> 찾고자 하는 값<br>  <code>@param?</code> 검색을 시작할 index의 위치<br>  <strong>indexOf</strong>(value, index)<br>  <strong>lastIndexOf</strong>(value, index)</p>
</blockquote>
<p>첫 번째 인자는 <strong>배열에서 찾고자 하는 값</strong>이다.<br>두 번째 인자는 생략이 가능한데, 이 인자를 사용해 <strong>검색을 시작할 배열 인덱스</strong>를 지정할 수 있다.<br>만약 두 번째 인자를 지정하지 않으면, <strong>indexOf()</strong>는 배열의 앞에서부터 검색을 시작하고,<br><strong>lastIndexOf()</strong>는 배열의 마지막부터 검색을 시작한다.<br>두 번째 인자로 음수를 사용할 수 있는데, 이 값은 배열의 마지막 원소로부터 상대적인 위치다.<br>이는 splice() 메서드의 두 번째 인자와 동일하다. (-1은 배열의 마지막 원소다)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 test에서 x인 값을 포함한 원소의 인덱스를 배열로 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">test, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [],       <span class="comment">// 반환할 인덱스를 담은 배열</span></span><br><span class="line">        len = test.length,  <span class="comment">// 검색할 배열 test의 길이</span></span><br><span class="line">        pos = <span class="number">0</span>;            <span class="comment">// 검색을 시작할 위치</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 검색할 원소가 있다면 실행</span></span><br><span class="line">    <span class="keyword">while</span>(pos &lt; len) &#123;</span><br><span class="line">        pos = test.indexOf(x, pos); <span class="comment">// 검색</span></span><br><span class="line">        <span class="keyword">if</span> (pos === <span class="number">-1</span>) &#123;           <span class="comment">// 찾을수 없다면</span></span><br><span class="line">            <span class="keyword">break</span>;                  <span class="comment">// while문을 탈출</span></span><br><span class="line">        &#125;</span><br><span class="line">        results.push(pos);          <span class="comment">// 찾았다면 반환할 배열에 인덱스를 저장</span></span><br><span class="line">        pos = pos + <span class="number">1</span>;              <span class="comment">// 검새 시 시작할 인덱스 위치를 다음 원소로 지정</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;     <span class="comment">// 찾은 원소의 인덱스를 담은 배열을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="배열-타입"><a href="#배열-타입" class="headerlink" title="배열 타입"></a>배열 타입</h1><p>배열을 특별한 형태의 객체다.<br>객체가 배열인지 여부를 판별하는 작업은 매우 유용하다.<br><em>ECMAScript 5</em>에서는 <strong>Array.isArray()</strong>라는 메서드를 통해 특정 객체가 배열인지 여부를 판단할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><em>ECMAScript 5</em> 이전에는 임의의 객체가 배열인지를 판달하기가 어려웠다.<br>이는 <code>typeof</code> 연산자가 배열뿐 아니라 함수를 제외한 모든 객체에 대해 “object”를 반환하기 때문이다.<br>단순한 형태의 경우라면 다음과 같이 <code>instanceof</code> 연산자를 사용할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;    <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Array</span>;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>그러나 <code>instanceof</code>를 사용하면 웹브라우저에 문제가 생길 수 있는데,<br>종종 하나 이상의 창 또는 프레임이 열려 있을 경우 문제가 발생한다.<br><strong>각 창 또는 프레임은 고유한 자바스크립트 실행 환경과 전역 객체를 가지고 있다.</strong><br>또한, 각각의 전역 객체는 별도의 생성자 함수들을 가지고 있다.<br>따라서 <strong>하나의 프레임에 속한 객체는 다른 프레임에 속한 생성자의 인스턴스가 될 수 없다.</strong><br>프레임 간의 혼동이 자주 발생하지는 않지만, <code>instanceof</code> 연산자로는 배열인지 확실하게 검증할 수 없다는 뜻이다.</p>
<p>이를 해결하기 위해서는 객체의 <strong>class</strong> 속성을 참고할 필요가 있다.<br>배열의 경우, <strong>class</strong> 속성은 항상 “Array” 값을 가지고 있고, 이를 이용하면 검증할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Object.prototype.toString를 이용해 class 속성을 얻는다</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>ECMAScript 5</em>의 <strong>Array.isArray()</strong> 메서드도 위와 같이 <strong>class</strong> 속성을 검사하는 방법을 사용하고 있다.<br><br><br><br></p>
<h1 id="유사-배열-객체"><a href="#유사-배열-객체" class="headerlink" title="유사 배열 객체"></a>유사 배열 객체</h1><p>자바스크립트 배열에는 다른 객체에 없는 몇 가지 특징이 있다.</p>
<ul>
<li>length 프로퍼티는 배열에 새 원소가 추가될 때 마다 자동으로 갱신된다.</li>
<li>length 값을 임의로 설정함으로써 배열의 크기를 줄일 수 있다.</li>
<li>배열은 Array.prototype에 정의된 유용한 메서드들을 상속한다.</li>
<li>배열의 class 속성 값은 “Array”로 설정된다.</li>
</ul>
<p>이것은 일반 객체와는 다른, 자바스크립트 배열만의 고유한 특징이다.<br>그러나 이것이 배열의 핵심적인 특징은 아니다.<br>length 프로퍼티와 양의 정수 이름의 프로퍼티가 있는 객체는 일종의 배열로 취급할 수 있는 것이다.</p>
<p>이처럼 “배열과 유사한” 객체는 실무에서 자주 나타난다.<br>비록 배열 메서드를 직접 호출한다던가 length 프로퍼티가 배열에 고유한 어떤 동작을 하리라고 기대할 수는 없지만,<br>실제 배열을 순회하는데 사용했던 기존 코드를 그대로 활용 할 수 있다.<br>실제로 수많은 배열 알고리즘이 기존 배열뿐 아니라 유사 배열 객체에서도 잘 작동한다.<br>작성한 알고리즘이 배열을 읽기 전용으로 다루거나 배열의 길이를 바꾸지 않는다면 더욱 그렇다.</p>
<p>다음 코드는 일반적인 객체를 배열과 유사한 객체로 만들기 위해 속성들을 추가한다.<br>이렇게 만들어진 유사 배열(pseudo-array)의 원소를 순회하는 예를 살펴본다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;&#125;;     <span class="comment">// 일반적인 빈 객체</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열과 유사한 객체로 만들기 위한 속성 추가</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    test[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">test.length = i;    <span class="comment">// test의 length를 i로</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 객체가 마치 실제 배열인 것처럼 반복문을 수행</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; test.length; j++) &#123;</span><br><span class="line">    total += test[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>클라이언트 측 자바스크립트는 document.getElementsByTagName()과 같은 상당수의 DOM 메서드가 배열과 유사한 객체를 반환한다.<br>아래의 함수는 객체가 배열과 유사한지 판별하는 함수이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o는 null이나 undefined 등등이 아님</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp;                <span class="comment">// o는 객체</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                   <span class="comment">// o의 길이는 유한하다</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o의 길이는 0 이상이다</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length는 정수다</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>) &#123;                <span class="comment">// o.length &lt; 2^32가 성립</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// o는 유사배열이다</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                       <span class="comment">// o는 배열과 비슷하지 않다</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><em>ECMAScript 5</em>에서는 문자열을 배열처럼 사용할 수 있다.<br>(<em>ECMAScript 5</em> 이전 버전을 사용하는 몇몇 브라우저에서는 문자열을 인덱스로 접근할 수 있다)<br>하지만, 문자열에 위의 함수를 적용해 보면 대체로 false가 반환된다.<br>문자열을 배열로 다루기보다 문자열 그 자체로 다루는 편이 최선이다.</p>
<p>자바스크립트 배열 메서드는 배열뿐 아니라 유사 배열 객체에도 적용이 가능하도록 범용(generic) 메서드로 구현되었다.<br><em>ECMAScript 5</em>의 모든 배열 메서드는 범용이다.<br><em>ECMAScript 3</em>에서는 toString()과 toLocaleString()을 제외한 모든 메서드가 범용이다.<br>(concat() 메서드는 예외다. 배열과 유사한 객체에 호출할 수 있으나, 반환될 배열에 해당 객체를 확장(extend)해 넣지는 못한다)</p>
<p>유사 배열은 Array.prototype을 상속받지 않기 때문에, 배열 메서드를 해당 객체의 메서드로 호출할 수 없다.<br>대신 Function.call 메서드를 통해 간접적으로 호출할 수는 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;<span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>:<span class="string">"b"</span>, <span class="string">"2"</span>:<span class="string">"c"</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;; <span class="comment">// 배열과 유사한 객체</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(test, <span class="string">"+"</span>);               <span class="comment">// "a+b+c"</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(test, <span class="number">0</span>);                <span class="comment">// ["a","b","c"]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(test, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;);                                                 <span class="comment">// ["A","B","C"]</span></span><br></pre></td></tr></table></figure></p>
<p>call() 메서드는 Function 객체의 메서드다.</p>
<p>파이어폭스는 Array의 생성자를 통해 사용할 수 있는 버전도 정의하였다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trst = &#123;<span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>:<span class="string">"b"</span>, <span class="string">"2"</span>:<span class="string">"c"</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;; <span class="comment">// 배열과 유사한 객체</span></span><br><span class="line"><span class="built_in">Array</span>.join(test, <span class="string">"+"</span>);</span><br><span class="line"><span class="built_in">Array</span>.slice(test, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Array</span>.map(test, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>하지만 이러한 정적 함수 형태의 배열 메서드는 유사 배열을 다룰 떄 유용하지만 표준이 아니라서 모든 브라우저가 지원한다는 보장이 없다.<br>그래서 다음과 같이 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.join = <span class="built_in">Array</span>.join || <span class="function"><span class="keyword">function</span>(<span class="params">obj, sep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(obj, sep);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.slice = <span class="built_in">Array</span>.slice || <span class="function"><span class="keyword">function</span>(<span class="params">obj, from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(obj, <span class="keyword">from</span>, to);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.map = <span class="built_in">Array</span>.map || <span class="function"><span class="keyword">function</span>(<span class="params">obj, func, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.map.call(obj, func, thisArg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="문자열을-배열처럼-사용하기"><a href="#문자열을-배열처럼-사용하기" class="headerlink" title="문자열을 배열처럼 사용하기"></a>문자열을 배열처럼 사용하기</h1><p><em>ECMAScript 5</em>(뿐 아니라 <em>ECMAScript 5</em> 이전 버전을 사용하는 IE 8을 포함한 대부분의 최근 브라우저)에서 문자열은 읽기 전용 배열처럼 동작한다.<br>문자열의 각 문자는 charAt() 메서드로 접근할 수도 있지만, 대부분 대괄호(<code>[]</code>)를 사용해 접근할 수도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">"test"</span>;</span><br><span class="line">test.charAt(<span class="number">0</span>); <span class="comment">// "t"</span></span><br><span class="line">test[<span class="number">1</span>];        <span class="comment">// "e"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><code>typeof</code> 연산자는 문자열에 대해서 여전히 “string”을 반환한다.<br>문자열을 Array.isArray()에 넘겨보면 false가 반환된다.</p>
<p>문자열을 인덱스로 접근함으로써 얻을 수 있는 가장 큰 장점은 charAt() 메서드 호출을 단순하게 <code>[]</code>로 대체할 수 있다는 것이다.<br>대체함으로써 코드가 전보다 간결해지고 가독성이 높아지므로 기존의 메서드를 사용할 때보다 더 효율적이다.</p>
<p>중요한 사실은 문자열에 범용 배열 메서드들을 바로 사용할 수 있다는 점이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">"JavaScript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(test, <span class="string">" "</span>);   <span class="comment">// "J a v a S c r i p t"</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call(test, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.match(<span class="regexp">/[^aeiou]/</span>); <span class="comment">// 오직 모음인 경우에만 true</span></span><br><span class="line">&#125;).join(<span class="string">""</span>);    <span class="comment">// "JvScrpt": 모음이 제거됨</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>문자열은 변하지 않는 값이라서, 읽기 전용 배열로만 다를 수 있다.<br>push()와 sort(), reverse(), splice()와 같은 배열 메서드는 배열을 직접 수정하므로 문자열에는 동작하지 않는다.<br>그러나 배열 메서드를 사용해 문자열을 수정하려고 해도 오류는 발생하지는 않고, 부수 효과없이 종료된다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/circleGiven" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/in/wonjune/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-03-24T08:03:55.846Z"><meta itemprop="articleBody" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다.
자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다.배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도..."><meta itemprop="url" content="http://yoursite.com/2018/03/10/javascript-array/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/03/10/javascript-array/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/08/javascript-type/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 타입, 값, 변수</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/16/javascript-object/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 객체</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/09/null-undefined/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript&gt;&gt; null vs undefined</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/04/04/spring-framework/">Spring | 프레임워크</a></li><li class="recent-posts__item"><a href="/2018/04/03/ajax-description/">Ajax | Ajax란?</a></li><li class="recent-posts__item"><a href="/2018/03/31/javascript-dom/">Javascript | 문서 객체 모델 (DOM)</a></li><li class="recent-posts__item"><a href="/2018/03/27/javascript-function/">Javascript | 함수</a></li><li class="recent-posts__item"><a href="/2018/03/24/book-javascript-guide/">Book | 자바스크립트 완벽 가이드</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ajax/">Ajax</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Basic/">Basic</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program/">Program</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Program/SICP/">SICP</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Speech/">Speech</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>